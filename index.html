<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Grid Territory Multiplayer</title>
  <style>
    body,html { margin:0; padding:0; height:100%; font-family:sans-serif; }
    /* Overlays */
    #setupOverlay, #lobbyOverlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(255,255,255,0.95);
      display:flex; align-items:center; justify-content:center; z-index:10;
    }
    .dialog {
      background:#fff; padding:20px; border:1px solid #ccc; border-radius:4px;
      max-width:400px; width:100%;
    }
    .player-row { display:flex; align-items:center; margin-bottom:8px; }
    .player-row label { flex:1; }
    /* Main game */
    #wrapper { display:none; height:100%; flex-direction:column; }
    #wrapper.flex { display:flex; }
    #main { display:flex; flex:1; }
    #game-container { position:relative; }
    canvas {
      position:absolute;
      top:0; left:0;
      background:#fff;
      /* Invisible one-cell border for easier hits */
      border:20px solid transparent;
      box-sizing: content-box; /* ensure border sits outside drawing area */
    }
    #sidebar { margin-left:20px; width:250px; }
    #chatLog {
      overflow-y:auto; height:200px; border:1px solid #ccc; padding:5px;
      resize: vertical; min-height:100px; max-height:400px;
    }
    #info { margin-top:8px; font-weight:600; }
    #hoverInfo { margin-top:4px; font-size:.9em; color:#333; }
    #debug { margin-top:8px; font-size:.8em; color:#a00; white-space:pre-wrap; }
    button { margin-top:8px; padding:6px 12px; font-size:.9rem; cursor:pointer; }
    select,input[type="text"],input[type="number"] { width:100%; padding:4px; box-sizing:border-box; }
    /* Tighter spacing for local setup rows */
    #localPlayersConfig .player-row { margin-bottom:4px; }
    /* Sidebar sections */
    #scoreboard, #lastResult, #possibleMovesDisplay { margin-top:16px; }
    #scoreboard ul { list-style:none; padding-left:0; }
  </style>
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore-compat.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyAlZwiFJYt73ZamlICtOSRUMOmEujPahTY",
      authDomain: "territory-58483.firebaseapp.com",
      projectId: "territory-58483",
      storageBucket: "territory-58483.firebasestorage.app",
      messagingSenderId: "848779508191",
      appId: "1:848779508191:web:54af4953cb1ce7c8b5ac6a",
      measurementId: "G-MH6R28JNMQ"
    };
    firebase.initializeApp(firebaseConfig);
    firebase.auth().signInAnonymously()
      .then(() => console.log("Signed in anonymously, UID =", firebase.auth().currentUser.uid))
      .catch(err => console.error("Auth failed:", err));
    const db = firebase.firestore();
  </script>
</head>
<body>
  <!-- Setup, Lobby, etc (unchanged) ... -->
  <!-- Main Game UI -->
  <div id="wrapper">
    <h2>Grid Territory</h2>
    <div id="main">
      <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="hoverInfo"></div>
      </div>
      <div id="sidebar">
        <!-- Chat -->
        <div id="chatSection" style="display:none;">
          <h4>Chat</h4>
          <div id="chatLog"></div>
          <input id="chatInput" type="text" placeholder="Type message..."/>
          <button id="chatSendBtn">Send</button>
        </div>
        <!-- Scoreboard -->
        <div id="scoreboard">
          <h4>Scoreboard</h4>
          <ul id="scoreList"></ul>
        </div>
        <!-- Possible moves left -->
        <div id="possibleMovesDisplay">
          Possible moves: <span id="possibleCount">0</span>
        </div>
        <!-- Last game result -->
        <div id="lastResult">
          <h4>Last Game Result</h4>
          <div id="lastResultText">—</div>
        </div>
      </div>
    </div>
    <div id="info">Waiting…</div>
    <div id="debug"></div>
    <button id="restartBtn">Restart Game</button>
    <button id="pingBtn">Ping</button>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const $ = id => document.getElementById(id);

    // UI refs
    const canvas            = $('gameCanvas'),
          ctx               = canvas.getContext('2d'),
          gameContainer     = $('game-container'),
          modeRadios        = document.getElementsByName('mode'),
          gridSizeConfig    = $('gridSizeConfig'),
          gridSizeSelect    = $('gridSizeSelect'),
          localConfig       = $('localConfig'),
          hostConfig        = $('hostConfig'),
          joinConfig        = $('joinConfig'),
          playerCountIn     = $('playerCount'),
          localPlayersConfig= $('localPlayersConfig'),
          startBtn          = $('startBtn'),
          setupOverlay      = $('setupOverlay'),
          lobbyOverlay      = $('lobbyOverlay'),
          lobbyGameIdEl     = $('lobbyGameId'),
          maxPlayersEl      = $('maxPlayersDisplay'),
          joinedCountEl     = $('joinedCount'),
          lobbyList         = $('lobbyPlayersList'),
          myNameInput       = $('myName'),
          myColorSelect     = $('myColor'),
          readyBtn          = $('readyBtn'),
          hostStartBtn      = $('hostStartBtn'),
          wrapper           = $('wrapper'),
          chatSection       = $('chatSection'),
          chatLog           = $('chatLog'),
          chatInput         = $('chatInput'),
          chatSendBtn       = $('chatSendBtn'),
          infoEl            = $('info'),
          hoverInfoEl       = $('hoverInfo'),
          debugEl           = $('debug'),
          restartBtn        = $('restartBtn'),
          pingBtn           = $('pingBtn'),
          scoreListUl       = $('scoreList'),
          possibleCountEl   = $('possibleCount'),
          lastResultTextEl  = $('lastResultText');

    const DEFAULT_COLORS = [
      '#006400','#ff0000','#ffd700','#c71585',
      '#00ff00','#00ffff','#0000ff','#1e90ff'
    ];

    let mode, gridSize, maxPlayers, myIndex, gameRef, started=false;
    let players=[], lines=[], chatArr=[], turnIndex=0;
    let endpoints,mids,horiz,vert,cells;
    const cellPx = 20;
    const borderPx = cellPx;   // must match CSS border

    // Ping state: only one rect, blinks twice (4 toggles)
    let pings = [], pingMode=false, pingToggle=true;

    // Game-over flag
    let gameOver = false;

    // Show/hide setup panels
    function updateConfig(){
      mode = document.querySelector('input[name=mode]:checked').value;
      gridSizeConfig.style.display = (mode==='join')?'none':'block';
      localConfig .style.display = (mode==='local')?'block':'none';
      hostConfig  .style.display = (mode==='host')?'block':'none';
      joinConfig  .style.display = (mode==='join')?'block':'none';
    }
    modeRadios.forEach(r=>r.addEventListener('change',updateConfig));
    updateConfig();

    // Render local-player inputs
    function renderLocalPlayerConfig(){
      const cnt=+playerCountIn.value;
      localPlayersConfig.innerHTML='';
      for(let i=1;i<=cnt;i++){
        const div=document.createElement('div');
        div.className='player-row';
        div.innerHTML=`
          <label>Name:
            <input type="text" class="localNameInput" data-idx="${i-1}" value="Player ${i}"/>
          </label>
          <label>Color:
            <select class="localColorSelect" data-idx="${i-1}">
              ${DEFAULT_COLORS.map((c,j)=>
                `<option value="${c}" ${j===i-1?'selected':''}>${c}</option>`
              ).join('')}
            </select>
          </label>
        `;
        localPlayersConfig.append(div);
      }
    }
    renderLocalPlayerConfig();
    playerCountIn.addEventListener('input',renderLocalPlayerConfig);

    // Convert raw px (including border) → grid coord
    function px2g(rawPx){
      const contentPx = rawPx - borderPx;
      return Math.min(Math.max(Math.round(contentPx/cellPx),0), gridSize-1);
    }
    function g2px(g){ return g*cellPx; }

    // Initialize board arrays
    function makeEmptyCells(){
      return Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(0));
    }
    function initializeGame(){
      endpoints = Array.from({length:gridSize},()=>Array(gridSize).fill(false));
      mids      = Array.from({length:gridSize},()=>Array(gridSize).fill(false));
      horiz     = Array.from({length:gridSize},()=>Array(gridSize-1).fill(false));
      vert      = Array.from({length:gridSize-1},()=>Array(gridSize).fill(false));
      cells     = makeEmptyCells();
    }

    // Occupy and flood-fill
    function canPass(x,y,nx,ny){
      if(x===nx) return !horiz[Math.min(y,ny)+1][x];
      else       return !vert[y][Math.min(x,nx)+1];
    }
    function fillTerritories(pl){
      const rows=gridSize-1, cols=gridSize-1;
      const vis=Array.from({length:rows},()=>Array(cols).fill(false));
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          if(vis[y][x]||cells[y][x]!==0) continue;
          let queue=[{x,y}], region=[], escapes=false;
          vis[y][x]=true;
          while(queue.length){
            const {x:cx,y:cy}=queue.shift();
            region.push({x:cx,y:cy});
            // check escape to border
            if(cx===0      && !vert[cy][0])    escapes=true;
            if(cx===cols-1 && !vert[cy][cols]) escapes=true;
            if(cy===0      && !horiz[0][cx])   escapes=true;
            if(cy===rows-1 && !horiz[rows][cx])escapes=true;
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
              const nx=cx+dx, ny=cy+dy;
              if(nx>=0&&nx<cols&&ny>=0&&ny<rows&&
                 !vis[ny][nx]&&canPass(cx,cy,nx,ny)){
                vis[ny][nx]=true;
                queue.push({x:nx,y:ny});
              }
            });
          }
          if(!escapes){
            region.forEach(pt=>cells[pt.y][pt.x]=pl+1);
          }
        }
      }
    }
    function occupy(sx,sy,ex,ey,p){
      if(sx===ex){
        const y0=Math.min(sy,ey);
        for(let d=0;d<3;d++) vert[y0+d][sx]=true;
      } else {
        const x0=Math.min(sx,ex);
        for(let d=0;d<3;d++) horiz[sy][x0+d]=true;
      }
      endpoints[sy][sx]=true;
      endpoints[ey][ex]=true;
      const midsNew=[
        {x:sx+(ex-sx)/3,   y:sy+(ey-sy)/3},
        {x:sx+2*(ex-sx)/3, y:sy+2*(ey-sy)/3}
      ];
      midsNew.forEach(m=>mids[m.y][m.x]=true);
      fillTerritories(p);
    }

    // Validation
    function isStraight3(sx,sy,ex,ey){
      const dx=Math.abs(ex-sx), dy=Math.abs(ey-sy);
      return (dx===3&&dy===0)||(dx===0&&dy===3);
    }
    function isConnected(sx,sy,ex,ey){
      if(lines.length===0) return true;
      const pts=[
        {x:sx,y:sy},{x:ex,y:ey},
        {x:sx+(ex-sx)/3,   y:sy+(ey-sy)/3},
        {x:sx+2*(ex-sx)/3, y:sy+2*(ey-sy)/3}
      ];
      return pts.some(pt=>
        endpoints[pt.y][pt.x]||mids[pt.y][pt.x]
      );
    }
    function noNodeReuse(sx,sy,ex,ey){
      const midsNew=[
        {x:sx+(ex-sx)/3,   y:sy+(ey-sy)/3},
        {x:sx+2*(ex-sx)/3, y:sy+2*(ey-sy)/3}
      ];
      return midsNew.every(m=>!mids[m.y][m.x]);
    }
    function noTerritory(sx,sy,ex,ey){
      if(sx===ex){
        const y0=Math.min(sy,ey);
        for(let d=0;d<3;d++){
          const y=y0+d;
          if((sx-1>=0 && cells[y][sx-1]!==0)||
             (sx<gridSize-1 && cells[y][sx]!==0))
            return false;
        }
      } else {
        const x0=Math.min(sx,ex);
        for(let d=0;d<3;d++){
          const x=x0+d;
          if((sy-1>=0 && cells[sy-1][x]!==0)||
             (sy<gridSize-1 && cells[sy][x]!==0))
            return false;
        }
      }
      return true;
    }
    // Only forbid *mutual* endpoint↔midpoint crossing
    function noMutualEndpointMidViolation(sx,sy,ex,ey){
      const midsNew=[
        {x:sx+(ex-sx)/3,   y:sy+(ey-sy)/3},
        {x:sx+2*(ex-sx)/3, y:sy+2*(ey-sy)/3}
      ];
      const endsNew=[{x:sx,y:sy},{x:ex,y:ey}];
      for(const ln of lines){
        const midsOld=[
          {x:ln.sx+(ln.ex-ln.sx)/3,   y:ln.sy+(ln.ey-ln.sy)/3},
          {x:ln.sx+2*(ln.ex-ln.sx)/3, y:ln.sy+2*(ln.ey-ln.sy)/3}
        ];
        const endsOld=[{x:ln.sx,y:ln.sy},{x:ln.ex,y:ln.ey}];
        const epOnOldMid = endsNew.some(eN=>
          midsOld.some(mO=>eN.x===mO.x&&eN.y===mO.y)
        );
        const oldEpOnNewMid = endsOld.some(eO=>
          midsNew.some(mN=>eO.x===mN.x&&eO.y===mN.y)
        );
        if(epOnOldMid && oldEpOnNewMid) return false;
      }
      return true;
    }

    // Draw everything
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // grid lines
      ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
      for(let i=0;i<gridSize;i++){
        const p=g2px(i);
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,canvas.height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(canvas.width,p);   ctx.stroke();
      }
      // territories
      cells.forEach((row,y)=>
        row.forEach((c,x)=>{
          if(c>0){
            ctx.globalAlpha=0.2;
            ctx.fillStyle=players[c-1].color;
            ctx.fillRect(g2px(x),g2px(y),cellPx,cellPx);
            ctx.globalAlpha=1;
          }
        })
      );
      // lines (last one thicker)
      lines.forEach((ln,i)=>{
        ctx.beginPath();
        ctx.setLineDash([]);
        ctx.lineCap='round';
        ctx.lineWidth = (i===lines.length-1?6:4);
        ctx.strokeStyle = players[ln.playerIndex].color;
        ctx.moveTo(g2px(ln.sx),g2px(ln.sy));
        ctx.lineTo(g2px(ln.ex),g2px(ln.ey));
        ctx.stroke();
      });
      // ping blink (only while ping.blinkCount>0)
      if(pings.length && pingToggle){
        ctx.font=`${cellPx}px sans-serif`;
        pings.forEach(r=>{
          for(let dx=0;dx<r.w;dx++){
            for(let dy=0;dy<r.h;dy++){
              ctx.fillText('⚠️', g2px(r.x+dx), g2px(r.y+dy+1));
            }
          }
        });
      }
    }

    // Info & scoreboard
    function updateInfo(){
      const cnts=players.map(()=>0);
      cells.forEach((row,y)=>row.forEach((c,x)=>{ if(c>0) cnts[c-1]++; }));
      infoEl.textContent = 
        `Turn: ${players[turnIndex].name} | `+
        players.map((p,i)=>`${p.name}: ${cnts[i]}`).join(', ');
    }
    function updateScoreboard(){
      const cnts=players.map(()=>0);
      cells.forEach((row,y)=>row.forEach((c,x)=>{ if(c>0) cnts[c-1]++; }));
      scoreListUl.innerHTML='';
      players.forEach((p,i)=>{
        const li=document.createElement('li');
        li.textContent=`${p.name}: ${cnts[i]}`;
        scoreListUl.append(li);
      });
    }
    function countPossibleMoves(){
      let c=0;
      for(let y=0;y<gridSize;y++){
        for(let x=0;x<gridSize;x++){
          [[3,0],[-3,0],[0,3],[0,-3]].forEach(([dx,dy])=>{
            const ex=x+dx, ey=y+dy;
            if(ex<0||ex>=gridSize||ey<0||ey>=gridSize) return;
            if(isStraight3(x,y,ex,ey)
              && isConnected(x,y,ex,ey)
              && noNodeReuse(x,y,ex,ey)
              && noTerritory(x,y,ex,ey)
              && noMutualEndpointMidViolation(x,y,ex,ey)) {
              c++;
            }
          });
        }
      }
      return c;
    }
    function updatePossibleMoves(){
      const c=countPossibleMoves();
      possibleCountEl.textContent=c;
      if(c===0 && !gameOver) endGame();
    }

    // Endgame
    async function endGame(){
      gameOver=true;
      const cnts=players.map(()=>0);
      cells.forEach((row,y)=>row.forEach((c,x)=>{ if(c>0) cnts[c-1]++; }));
      const maxTerr=Math.max(...cnts),
            winnerIdx=cnts.indexOf(maxTerr),
            winnerName=players[winnerIdx].name;
      alert(`Game over! ${winnerName} wins with ${maxTerr} territories.`);
      if(mode!=='local'){
        await db.collection('gameResults').add({
          players: players.map(p=>({id:p.id,name:p.name})),
          scores: cnts,
          winnerIndex: winnerIdx,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
    }

    // Ping blink timer: blink twice (4 toggles), then clear
    setInterval(()=>{
      pingToggle = !pingToggle;
      if(pings.length){
        pings.forEach(p=>p.blinkCount--);
        if(pings[0].blinkCount <= 0) pings = [];
      }
      draw();
    }, 500);

    // Mouse handlers
    let clickStart=null, hoverEnd=null;
    canvas.addEventListener('mousemove', e=>{
      const r=canvas.getBoundingClientRect(),
            gx=px2g(e.clientX - r.left),
            gy=px2g(e.clientY - r.top);
      hoverEnd={x:gx,y:gy};
      if(clickStart){
        draw();
        ctx.beginPath();
        ctx.setLineDash([5,5]);
        ctx.lineWidth=2; ctx.strokeStyle='gray';
        ctx.moveTo(g2px(clickStart.x),g2px(clickStart.y));
        ctx.lineTo(g2px(hoverEnd.x),g2px(hoverEnd.y));
        ctx.stroke();
        ctx.setLineDash([]);
      } else {
        draw();
        hoverInfoEl.textContent=`Hovered: (${gx},${gy})`;
      }
    });
    canvas.addEventListener('mouseleave',()=>hoverInfoEl.textContent='');

    canvas.addEventListener('click', async e=>{
      const r=canvas.getBoundingClientRect(),
            gx=px2g(e.clientX - r.left),
            gy=px2g(e.clientY - r.top);

      // Ping mode: single cell, blink twice
      if(pingMode){
        pings = [{ x:gx, y:gy, w:1, h:1, blinkCount:4 }];
        pingMode = false;
        draw();
        return;
      }

      // Not started or over?
      if((mode!=='local' && !started) || gameOver){
        debugEl.textContent = gameOver ? 'Game over.' : 'Not started yet.';
        return;
      }
      if(mode!=='local' && turnIndex!==myIndex){
        debugEl.textContent='Not your turn.';
        clickStart = null;
        return;
      }

      // Line placement
      if(!clickStart){
        clickStart = {x:gx,y:gy};
        return;
      }
      const sx=clickStart.x, sy=clickStart.y,
            ex=gx, ey=gy;
      clickStart=null;
      debugEl.textContent='';

      if(!isStraight3(sx,sy,ex,ey))             debugEl.textContent='Line must be straight & length 3.';
      else if(!isConnected(sx,sy,ex,ey))        debugEl.textContent='Must touch existing point.';
      else if(!noNodeReuse(sx,sy,ex,ey))        debugEl.textContent='Cannot cross existing line interior.';
      else if(!noTerritory(sx,sy,ex,ey))        debugEl.textContent='Cannot go through occupied territory.';
      else if(!noMutualEndpointMidViolation(sx,sy,ex,ey))
                                                debugEl.textContent='Illegal mutual endpoint↔midpoint cross.';
      else {
        if(mode!=='local'){
          const newLines=[...lines,{sx,sy,ex,ey,playerIndex:turnIndex}];
          const next=(turnIndex+1)%players.length;
          await gameRef.update({
            lines:newLines,
            turnIndex: next,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
        } else {
          lines.push({sx,sy,ex,ey,playerIndex:turnIndex});
          occupy(sx,sy,ex,ey,turnIndex);
          turnIndex=(turnIndex+1)%players.length;
          draw(); updateInfo(); updateScoreboard(); updatePossibleMoves();
        }
      }
    });

    // Chat send
    chatSendBtn.onclick = () => {
      const text=chatInput.value.trim();
      if(!text) return;
      const now=firebase.firestore.Timestamp.now();
      const msg={ senderId:clientId, senderName:players[myIndex].name, text, timestamp:now };
      gameRef.update({
        chat: firebase.firestore.FieldValue.arrayUnion(msg),
        lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
      });
      chatInput.value='';
    };

    // Ping button
    pingBtn.onclick = () => {
      pingMode=true;
      debugEl.textContent='Click the cell to ping';
    };

    // Restart
    restartBtn.onclick = async ()=>{
      if(mode==='local'){
        lines=[]; turnIndex=0; initializeGame(); draw();
        updateInfo(); updateScoreboard(); updatePossibleMoves();
        gameOver=false;
      } else {
        // new game doc, keep old history
        const newId=Math.random().toString(36).substr(2,9);
        history.replaceState(null,'','?game='+newId);
        const dim=parseInt(gridSizeSelect.value,10);
        await db.collection('games').doc(newId).set({
          maxPlayers, players, turnIndex:0,
          lines:[], chat:[], started:true,
          gridSizeDim: dim,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        gameRef=db.collection('games').doc(newId);
        gameOver=false;
        gameRef.onSnapshot(doc=>handleSnapshot(doc.data()));
      }
    };

    // Start button (setup→play)
    startBtn.onclick = async ()=>{
      mode = document.querySelector('input[name=mode]:checked').value;
      const dim=parseInt(gridSizeSelect.value,10);
      if(mode!=='join'){
        gridSize=dim+1;
        canvas.width=canvas.height=cellPx*dim;
        gameContainer.style.width=canvas.width+'px';
        gameContainer.style.height=canvas.height+'px';
      }
      if(mode==='local'){
        maxPlayers=+playerCountIn.value;
        players=[];
        document.querySelectorAll('.localNameInput').forEach(el=>{
          const idx=+el.dataset.idx;
          const name=el.value||`Player ${idx+1}`;
          const color=document.querySelector(`.localColorSelect[data-idx="${idx}"]`).value;
          players.push({id:null,name,color,ready:true});
        });
        setupOverlay.style.display='none';
        initializeGame();
        draw(); updateInfo(); updateScoreboard(); updatePossibleMoves();
        wrapper.style.display='flex'; wrapper.classList.add('flex');
        return;
      }
      // online host/join
      maxPlayers=+playerCountIn.value;
      const gid=mode==='host'
        ?(() => {
           const id=Math.random().toString(36).substr(2,9);
           history.replaceState(null,'','?game='+id);
           return id;
         })()
        :joinGameId.value.trim();
      if(mode==='join'&&!gid) return alert('Enter Game ID');
      setupOverlay.style.display='none';
      lobbyOverlay.style.display='flex';
      lobbyGameIdEl.textContent=gid;
      maxPlayersEl.textContent=maxPlayers;
      gameRef=db.collection('games').doc(gid);
      if(mode==='host'){
        players=[{id:clientId,name:'Player 1',color:DEFAULT_COLORS[0],ready:false}];
        await gameRef.set({
          maxPlayers, players, turnIndex:0,
          lines:[], chat:[], started:false,
          gridSizeDim: dim,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
      } else {
        const snap=await gameRef.get();
        if(!snap.exists) return alert('Game not found');
        const data=snap.data();
        if(data.players.length>=data.maxPlayers) return alert('Game is full');
        players=data.players;
        players.push({
          id:clientId,
          name:`Player ${players.length+1}`,
          color:DEFAULT_COLORS[players.length%DEFAULT_COLORS.length],
          ready:false
        });
        await gameRef.update({players});
      }
      gameRef.onSnapshot(doc=>handleSnapshot(doc.data()));
    };

    // Lobby→game snapshot handler
    function handleSnapshot(data){
      players   =data.players;
      lines     =data.lines;
      chat      =data.chat;
      turnIndex =data.turnIndex;
      maxPlayers=data.maxPlayers;
      started   =data.started;
      if(!started){
        joinedCountEl.textContent=players.length;
        lobbyList.innerHTML='';
        players.forEach(p=>{
          const div=document.createElement('div'),
                sw=document.createElement('span');
          sw.style.cssText='display:inline-block;width:12px;height:12px;margin-right:5px;background:'+p.color;
          div.append(sw,p.name+(p.ready?' (Ready)':''));
          lobbyList.append(div);
        });
        myIndex=players.findIndex(p=>p.id===clientId);
        myNameInput.value   =players[myIndex].name;
        myColorSelect.value =players[myIndex].color;
        myNameInput.disabled=myColorSelect.disabled=readyBtn.disabled=false;
        readyBtn.textContent=(players[myIndex].ready?'Unready':'Ready');
        if(players[myIndex].id===clientId){
          hostStartBtn.style.display='inline-block';
          hostStartBtn.disabled=!(players.length===maxPlayers&&players.every(x=>x.ready));
        }
      } else {
        if(mode==='join'&&typeof data.gridSizeDim==='number'){
          const dim=data.gridSizeDim;
          gridSize=dim+1;
          canvas.width=canvas.height=cellPx*dim;
          gameContainer.style.width=canvas.width+'px';
          gameContainer.style.height=canvas.height+'px';
        }
        lobbyOverlay.style.display='none';
        wrapper.style.display='flex'; wrapper.classList.add('flex');
        chatSection.style.display='block';
        initializeGame();
        lines.forEach(ln=>occupy(ln.sx,ln.sy,ln.ex,ln.ey,ln.playerIndex));
        draw(); renderChat(); updateInfo(); updateScoreboard(); updatePossibleMoves();
      }
    }

    // Lobby controls
    readyBtn.onclick      =()=>{ players[myIndex].ready=!players[myIndex].ready; gameRef.update({players}); };
    hostStartBtn.onclick  =()=>gameRef.update({started:true, timestamp:firebase.firestore.FieldValue.serverTimestamp()});
    myNameInput.onchange  =()=>{ players[myIndex].name=myNameInput.value;    gameRef.update({players}); };
    myColorSelect.onchange=()=>{ players[myIndex].color=myColorSelect.value; gameRef.update({players}); };

    // Chat rendering
    function renderChat(){
      chatLog.innerHTML='';
      chat.sort((a,b)=>(a.timestamp.seconds||a.timestamp)-(b.timestamp.seconds||b.timestamp))
          .forEach(m=>{
            const t=m.timestamp.seconds
              ? new Date(m.timestamp.seconds*1000).toLocaleTimeString()
              : new Date(m.timestamp).toLocaleTimeString();
            const div=document.createElement('div');
            div.innerHTML=`<strong>${m.senderName}</strong> [${t}]: ${m.text}`;
            chatLog.append(div);
          });
      chatLog.scrollTop=chatLog.scrollHeight;
    }

    // Show last result
    db.collection('gameResults')
      .orderBy('timestamp','desc')
      .limit(1)
      .onSnapshot(snap=>{
        if(!snap.empty){
          const d=snap.docs[0].data(),
                w=d.players[d.winnerIndex].name,
                s=d.scores[d.winnerIndex];
          lastResultTextEl.textContent=`${w} won with ${s} territories.`;
        }
      });

  }); // end DOMContentLoaded
  </script>
</body>
</html>
