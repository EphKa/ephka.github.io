<!-- Grid Territory — same mechanics, now online with NetplayJS -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Grid Territory — online play</title>

<style>
  body,html{margin:0;padding:0;height:100%;font-family:sans-serif}
  #wrapper{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%}
  h2{margin:8px 0}
  #game-container{position:relative;width:420px;height:420px}
  canvas{position:absolute;top:0;left:0;background:#fff}
  #info{margin-top:8px;font-weight:600}
  #debug{margin-top:6px;font-size:.8em;color:#a00;white-space:pre-wrap}
  button{margin-top:12px;padding:8px 20px;font-size:1rem;cursor:pointer}
</style>
</head>
<body>
<div id="wrapper">
  <h2>Grid Territory (online two‑player)</h2>

  <div id="game-container">
    <canvas id="gameCanvas" width="420" height="420"></canvas>
  </div>

  <div id="info">Waiting for opponent…</div>
  <div id="debug"></div>
  <button id="restartBtn" disabled>Restart Game</button>
</div>

<!-- NetplayJS public bundle -->
<script src="https://unpkg.com/netplayjs@0.4.1/dist/netplay.js"
        integrity="sha384-6Yb8LWAT488jwK+nIjvD4S5/poq1Xn69NYjH1RXKHoaUOaFJrKQ1rfGQgKm8oQjX"
        crossorigin="anonymous"></script>

<script>
/* ── constants & utility mappers (unchanged) ───────────────────── */
const gridSize = 21, cellPx = 20;
const px2g = px => Math.round(px / cellPx);
const g2px =  g  => g * cellPx;
const $ = id => document.getElementById(id);

/* ── NetplayJS game wrapper for the original mechanics ─────────── */
class GridTerritoryGame extends netplayjs.Game {

  /* required static config */
  static timestep   = 1000 / 60;                    // 60 FPS
  static canvasSize = { width: 420, height: 420 };
  static numPlayers = { min: 2, max: 2 };

  constructor (canvas/*HTMLCanvasElement*/, players) {
    super();
    this.canvas = canvas;
    this.ctx    = canvas.getContext('2d');

    this.initState();              // same arrays & vars as your local version
    this.bindPointer();            // local mouse → queueLocalInput
    this.draw();                   // initial board
  }

  /* complete state reset — called at construction or wrapper.restart() */
  initState () {
    this.turn  = 1;
    this.lines = [];
    this.nodes = Array.from({length:gridSize}, ()=>Array(gridSize    ).fill(false));
    this.horiz = Array.from({length:gridSize}, ()=>Array(gridSize-1 ).fill(false));
    this.vert  = Array.from({length:gridSize-1}, ()=>Array(gridSize ).fill(false));
    this.cells = Array.from({length:gridSize-1}, ()=>Array(gridSize-1).fill(0));

    /* UI‑only, not serialised */
    this.clickStart = null;
    this.hoverEnd   = null;
  }

  /* attach mouse listeners that build finished‑drag packets */
  bindPointer () {
    const rect  = () => this.canvas.getBoundingClientRect();

    this.canvas.addEventListener('mousemove', e => {
      if (!this.clickStart) return;
      const r = rect();
      this.hoverEnd = { x:px2g(e.clientX - r.left), y:px2g(e.clientY - r.top) };
      this.draw();
    });

    this.canvas.addEventListener('click', e => {
      const r  = rect();
      const gx = px2g(e.clientX - r.left);
      const gy = px2g(e.clientY - r.top);

      /* first click just stores the anchor node */
      if (!this.clickStart) { this.clickStart = {x:gx,y:gy}; this.hoverEnd=null; return; }

      /* second click – propose a 3‑segment line */
      const line = {
        sx: this.clickStart.x, sy: this.clickStart.y,
        ex: (this.hoverEnd||{x:gx}).x,
        ey: (this.hoverEnd||{y:gy}).y
      };

      /* quick local legality check to give instant user feedback        */
      if (!this._isLegalLine(line.sx,line.sy,line.ex,line.ey)) {
        $('debug').textContent =
          'Illegal move: must be straight 3 cells, touch a node, avoid crossing.';
      } else {
        window.__wrapper.queueLocalInput(line);        // send to peer
        $('debug').textContent = '';
      }

      this.clickStart = this.hoverEnd = null;
      this.draw();                                     // clear preview
    });
  }

  /* -------------- NetplayJS frame step -------------------------- */
  tick (playerInputs) {
    /* whose turn should act this frame? 0‑based Netplay IDs */
    const expected = (this.turn === 1 ? 0 : 1);

    for (const [player, inp] of playerInputs.entries()) {
      if (player.getID() !== expected || !inp) continue;

      /* apply move if still legal in current state */
      if (this._isLegalLine(inp.sx,inp.sy,inp.ex,inp.ey)) {
        this._occupy(inp.sx,inp.sy,inp.ex,inp.ey, this.turn);
        this.turn = this.turn === 1 ? 2 : 1;
      }
    }
    this.draw();
  }

  /* ---------------- original helper/logic methods --------------- */
  _isStraight3 (sx,sy,ex,ey){
    const dx=Math.abs(ex-sx),dy=Math.abs(ey-sy);
    return (dx===3&&dy===0)||(dx===0&&dy===3);
  }
  _interior (sx,sy,ex,ey){
    return sx===ex
      ? [{x:sx,y:Math.min(sy,ey)+1},{x:sx,y:Math.min(sy,ey)+2}]
      : [{x:Math.min(sx,ex)+1,y:sy},{x:Math.min(sx,ex)+2,y:sy}];
  }
  _noCross (sx,sy,ex,ey){
    const ni=this._interior(sx,sy,ex,ey);
    return !this.lines.some(ln=>this._interior(ln.sx,ln.sy,ln.ex,ln.ey)
      .some(a=>ni.some(b=>a.x===b.x&&a.y===b.y)));
  }
  _touches (sx,sy,ex,ey){
    return this.lines.length===0 || this.nodes[sy][sx] || this.nodes[ey][ex];
  }
  _isLegalLine (sx,sy,ex,ey){
    return this._isStraight3(sx,sy,ex,ey) && this._touches(sx,sy,ex,ey) && this._noCross(sx,sy,ex,ey);
  }

  _occupy (sx,sy,ex,ey,p){
    this.lines.push({sx,sy,ex,ey,player:p});
    if (sx===ex){
      const x=sx,y0=Math.min(sy,ey);
      for(let d=0;d<3;d++){
        this.vert [y0+d][x]   = true;
        this.nodes[y0+d][x]   = true;
        this.nodes[y0+d+1][x] = true;
      }
    } else {
      const y=sy,x0=Math.min(sx,ex);
      for(let d=0;d<3;d++){
        this.horiz[y][x0+d]   = true;
        this.nodes[y][x0+d]   = true;
        this.nodes[y][x0+1+d] = true;
      }
    }
    this._fillTerritories(p);
  }

  _fillTerritories (p){
    const visited = Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(false));
    const q = [];
    for (let i=0;i<gridSize-1;i++)
      [[0,i],[gridSize-2,i],[i,0],[i,gridSize-2]]
      .forEach(([x,y])=>{ if(!visited[y][x]){ visited[y][x]=true; q.push({x,y}); } });

    const pass = (x,y,nx,ny) => x===nx
        ? !this.horiz[Math.min(y,ny)+1][x]
        : !this.vert [y][Math.min(x,nx)+1];

    while(q.length){
      const {x,y} = q.shift();
      [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
         const nx=x+dx, ny=y+dy;
         if (nx>=0 && nx<gridSize-1 && ny>=0 && ny<gridSize-1 &&
             !visited[ny][nx] && pass(x,y,nx,ny)){
           visited[ny][nx] = true; q.push({x:nx,y:ny});
         }
      });
    }
    for(let y=0;y<gridSize-1;y++)
      for(let x=0;x<gridSize-1;x++)
        if(!visited[y][x] && this.cells[y][x]===0) this.cells[y][x]=p;
  }

  /* --------------------------- drawing -------------------------- */
  draw () {
    const ctx=this.ctx;
    ctx.clearRect(0,0,420,420);

    /* grid */
    ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
    for(let i=0;i<=gridSize;i++){
      const p=g2px(i);
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,420); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(420,p); ctx.stroke();
    }

    /* filled cells */
    for(let y=0;y<gridSize-1;y++)
      for(let x=0;x<gridSize-1;x++)
        if(this.cells[y][x]>0){
          ctx.globalAlpha=.2;
          ctx.fillStyle=this.cells[y][x]==1?'red':'blue';
          ctx.fillRect(g2px(x),g2px(y),cellPx,cellPx);
          ctx.globalAlpha=1;
        }

    /* lines */
    for(const ln of this.lines){
      ctx.beginPath(); ctx.lineWidth=4;
      ctx.strokeStyle=ln.player==1?'red':'blue';
      ctx.moveTo(g2px(ln.sx),g2px(ln.sy));
      ctx.lineTo(g2px(ln.ex),g2px(ln.ey)); ctx.stroke();
    }

    /* local drag preview */
    if(this.clickStart && this.hoverEnd){
      ctx.beginPath();
      ctx.setLineDash([5,5]); ctx.lineWidth=2; ctx.strokeStyle='gray';
      ctx.moveTo(g2px(this.clickStart.x),g2px(this.clickStart.y));
      ctx.lineTo(g2px(this.hoverEnd.x),g2px(this.hoverEnd.y));
      ctx.stroke(); ctx.setLineDash([]);
    }

    /* status banner */
    $('info').textContent = `Turn: Player ${this.turn}`;
  }
}

/* ── bootstrap NetplayJS wrapper & simple UI signals ──────────── */
window.addEventListener('DOMContentLoaded', () => {
  /* make the wrapper global so the game’s pointer handler can call it */
  window.__wrapper = new netplayjs.RollbackWrapper(GridTerritoryGame);
  window.__wrapper.start();

  const info=$('info'), dbg=$('debug'), restart=$('restartBtn');

  window.__wrapper.on('connected', () => {
    info.textContent = 'Both players ready — Player 1 starts!';
    restart.disabled = false;
  });

  window.__wrapper.on('exception', e => { dbg.textContent = e.message||e; });

  restart.onclick = () => { dbg.textContent=''; window.__wrapper.restart(); };
});
</script>
</body>
</html>
