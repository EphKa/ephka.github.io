<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Grid Territory Multiplayer</title>
  <style>
    body,html { margin:0; padding:0; height:100%; font-family:sans-serif; }
    /* Overlays */
    #setupOverlay, #lobbyOverlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(255,255,255,0.95);
      display:flex; align-items:center; justify-content:center; z-index:10;
    }
    .dialog {
      background:#fff; padding:20px; border:1px solid #ccc; border-radius:4px;
      max-width:400px; width:100%;
    }
    /* Main game */
    #wrapper { display:none; height:100%; flex-direction:column; }
    #wrapper.flex { display:flex; flex-direction:column; }
    #main { display:flex; flex:1; }
    #game-container { position:relative; width:420px; height:420px; }
    canvas { position:absolute; top:0; left:0; background:#fff; }
    #sidebar { margin-left:20px; width:200px; }
    #chatLog { overflow-y:auto; height:200px; border:1px solid #ccc; padding:5px; }
    #profileSection, #chatSection { margin-top:20px; }
    #info { margin-top:8px; font-weight:600; }
    #debug { margin-top:8px; font-size:.8em; color:#a00; white-space:pre-wrap; }
    button { margin-top:8px; padding:6px 12px; font-size:0.9rem; cursor:pointer; }
  </style>

  <!-- Firebase UMD (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore-compat.js"></script>
  <script>
    // YOUR CONFIG from Firebase console → Project Settings
    const firebaseConfig = {
      apiKey: "AIzaSyCfKDzCpj9KfQ_aglBZ1pHmtkD-XNKs8Gc",
      authDomain: "territory-game-860e8.firebaseapp.com",
      projectId: "territory-game-860e8",
      storageBucket: "territory-game-860e8.firebasestorage.app",
      messagingSenderId: "797594052134",
      appId: "1:797594052134:web:d452b45cdf98b9164de8e7",
      measurementId: "G-28RC8M9MKP"
    };
    firebase.initializeApp(firebaseConfig);
  </script>
</head>
<body>
  <!-- 1) Initial Setup -->
  <div id="setupOverlay">
    <div class="dialog">
      <h3>Setup Game</h3>
      <label><input type="radio" name="mode" value="local" checked> Local</label>
      <label style="margin-left:10px;"><input type="radio" name="mode" value="host"> Host Online</label>
      <label style="margin-left:10px;"><input type="radio" name="mode" value="join"> Join Online</label>

      <div id="hostConfig">
        <br/>
        <label>Players:
          <input type="number" id="playerCount" min="2" max="8" value="2"/>
        </label>
      </div>
      <div id="joinConfig" style="display:none;">
        <br/>
        <input id="joinGameId" type="text" placeholder="Enter Game ID to join" />
      </div>

      <button id="startBtn">Next →</button>
    </div>
  </div>

  <!-- 2) Lobby for online -->
  <div id="lobbyOverlay" style="display:none;">
    <div class="dialog">
      <h3>Game Lobby</h3>
      <p>Game ID: <strong id="lobbyGameId"></strong></p>
      <p>Players (<span id="joinedCount">0</span> / <span id="maxPlayersDisplay">0</span>):</p>
      <ul id="lobbyPlayersList"></ul>
      <button id="readyBtn">Ready</button>
      <button id="hostStartBtn" style="display:none;">Start Game</button>
    </div>
  </div>

  <!-- 3) Main Game UI -->
  <div id="wrapper">
    <h2>Grid Territory</h2>
    <div id="main">
      <div id="game-container">
        <canvas id="gameCanvas" width="420" height="420"></canvas>
      </div>
      <div id="sidebar">
        <div id="chatSection" style="display:none;">
          <h4>Chat</h4>
          <div id="chatLog"></div>
          <input id="chatInput" type="text" placeholder="Type message..." style="width:100%"/>
          <button id="chatSendBtn">Send</button>
        </div>
        <div id="profileSection" style="display:none;">
          <h4>Your Profile</h4>
          <label>Name: <input id="myName" type="text"/></label><br/>
          <label>Color: <input id="myColor" type="color"/></label>
        </div>
      </div>
    </div>
    <div id="info">Waiting…</div>
    <div id="debug"></div>
    <button id="restartBtn">Restart Game</button>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // Shortcuts
    const $ = id => document.getElementById(id);

    // Globals
    const clientId = Math.random().toString(36).substr(2,9);
    const defaultColors = ['#e6194b','#3cb44b','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c'];
    let mode, maxPlayers, myIndex, gameRef, started=false;
    let players = [], lines = [], chat = [], turnIndex = 0;
    // Firestore
    const db = firebase.firestore();

    // Elements
    const modeRadios    = document.getElementsByName('mode');
    const hostConfig    = $('hostConfig');
    const joinConfig    = $('joinConfig');
    const playerCountIn = $('playerCount');
    const joinGameId    = $('joinGameId');
    const startBtn      = $('startBtn');
    const lobbyOverlay  = $('lobbyOverlay');
    const setupOverlay  = $('setupOverlay');
    const lobbyGameIdEl = $('lobbyGameId');
    const maxPlayersEl  = $('maxPlayersDisplay');
    const joinedCountEl = $('joinedCount');
    const lobbyList     = $('lobbyPlayersList');
    const readyBtn      = $('readyBtn');
    const hostStartBtn  = $('hostStartBtn');
    const wrapper       = $('wrapper');
    const chatSection   = $('chatSection');
    const chatLog       = $('chatLog');
    const chatInput     = $('chatInput');
    const chatSendBtn   = $('chatSendBtn');
    const profileSection= $('profileSection');
    const myNameInput   = $('myName');
    const myColorInput  = $('myColor');
    const infoEl        = $('info');
    const debugEl       = $('debug');
    const restartBtn    = $('restartBtn');
    const canvas        = $('gameCanvas');
    const ctx           = canvas.getContext('2d');

    // Grid
    const gridSize=21, cellPx=20;
    let nodes, horiz, vert, cells;

    function px2g(px){return Math.round(px/cellPx);}
    function g2px(g){return g*cellPx;}
    function makeEmptyCells(){
      return Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(0));
    }

    // Initial setup display logic
    function updateConfigDisplay(){
      mode = document.querySelector('input[name=mode]:checked').value;
      hostConfig.style.display = (mode==='local'||mode==='host')?'block':'none';
      joinConfig.style.display = (mode==='join')?'block':'none';
    }
    modeRadios.forEach(r=>r.addEventListener('change',updateConfigDisplay));
    updateConfigDisplay();

    startBtn.onclick = () => {
      // Read mode
      mode = document.querySelector('input[name=mode]:checked').value;
      if (mode==='local'){
        // Local: set up players array
        maxPlayers = +playerCountIn.value;
        players = [];
        for(let i=0;i<maxPlayers;i++){
          players.push({ id:null, name:`Player ${i+1}`, color:defaultColors[i], ready:true });
        }
        // Start local
        setupOverlay.style.display='none';
        startLocal();
      }
      else if (mode==='host' || mode==='join'){
        maxPlayers = +playerCountIn.value;
        const gid = mode==='host'
          ? ( () => {
              const id = Math.random().toString(36).substr(2,9);
              history.replaceState(null,'','?game='+id);
              return id;
            })()
          : joinGameId.value.trim();
        if (mode==='join' && !gid) return alert('Enter a Game ID');
        // Show lobby
        setupOverlay.style.display='none';
        lobbyOverlay.style.display='flex';
        lobbyGameIdEl.textContent = gid;
        maxPlayersEl.textContent  = maxPlayers;
        initOnline(gid, mode==='host');
      }
    };

    // LOCAL MODE
    function startLocal(){
      initializeGameState();
      wrapper.classList.add('flex');
      wrapper.style.display='flex';
      infoEl.textContent = `Turn: ${players[turnIndex].name}`;
    }

    // ONLINE MODE
    async function initOnline(gameId, isHost){
      gameRef = db.collection('games').doc(gameId);
      if (isHost){
        // seed doc
        players = [{ id:clientId, name:'Player 1', color:defaultColors[0], ready:false }];
        await gameRef.set({
          maxPlayers, players, turnIndex:0,
          lines:[], chat:[], started:false
        });
      } else {
        const snap = await gameRef.get();
        if (!snap.exists) return alert('Game not found');
        const data = snap.data();
        if (data.players.length >= data.maxPlayers) {
          return alert('Game is full');
        }
        players = data.players;
        players.push({
          id:clientId,
          name:`Player ${players.length+1}`,
          color:defaultColors[players.length],
          ready:false
        });
        await gameRef.update({ players });
      }
      // Subscribe
      gameRef.onSnapshot(doc => handleSnapshot(doc.data(), isHost));
    }

    function handleSnapshot(data, isHost){
      // Sync state
      maxPlayers  = data.maxPlayers;
      players     = data.players;
      lines       = data.lines;
      chat        = data.chat;
      turnIndex   = data.turnIndex;
      started     = data.started;

      // Find myIndex
      myIndex = players.findIndex(p => p.id === clientId);

      if (!started){
        // Lobby UI
        joinedCountEl.textContent = players.length;
        lobbyList.innerHTML = '';
        players.forEach((p,i)=>{
          const li = document.createElement('li');
          const sw = document.createElement('span');
          sw.style.display='inline-block'; sw.style.width='12px';
          sw.style.height='12px'; sw.style.marginRight='5px';
          sw.style.background=p.color;
          li.append(sw, document.createTextNode(p.name + (p.ready?' (Ready)':'')));
          lobbyList.append(li);
        });
        // Ready button
        if (myIndex>=0){
          readyBtn.style.display='inline-block';
          readyBtn.textContent = players[myIndex].ready?'Unready':'Ready';
          readyBtn.disabled = false;
        } else {
          readyBtn.style.display='none';
        }
        // Host Start Game
        if (isHost){
          hostStartBtn.style.display='inline-block';
          const allReady = players.length===maxPlayers && players.every(p=>p.ready);
          hostStartBtn.disabled = !allReady;
        } else {
          hostStartBtn.style.display='none';
        }
      } else {
        // Game start
        lobbyOverlay.style.display='none';
        wrapper.classList.add('flex');
        wrapper.style.display='flex';
        chatSection.style.display='block';
        profileSection.style.display='block';
        initializeGameState();
        infoEl.textContent = `Turn: ${players[turnIndex].name}`;
        renderChat();
        myNameInput.value = players[myIndex].name;
        myColorInput.value = players[myIndex].color;
      }
    }

    // READY / START handlers
    readyBtn.onclick = () => {
      players[myIndex].ready = !players[myIndex].ready;
      gameRef.update({ players });
    };
    hostStartBtn.onclick = () => {
      gameRef.update({ started:true });
    };

    // CHAT
    chatSendBtn.onclick = () => {
      const text = chatInput.value.trim();
      if (!text) return;
      const msg = {
        senderId: clientId,
        senderName: myNameInput.value,
        text, timestamp: Date.now()
      };
      gameRef.update({
        chat: firebase.firestore.FieldValue.arrayUnion(msg)
      });
      chatInput.value = '';
    };
    function renderChat(){
      chatLog.innerHTML = '';
      chat.sort((a,b)=>a.timestamp-b.timestamp)
          .forEach(m=>{
            const div = document.createElement('div');
            const t = new Date(m.timestamp).toLocaleTimeString();
            div.innerHTML = `<strong>${m.senderName}</strong> [${t}]: ${m.text}`;
            chatLog.append(div);
          });
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    // PROFILE edits
    myNameInput.addEventListener('change', ()=>{
      players[myIndex].name = myNameInput.value;
      gameRef.update({ players });
    });
    myColorInput.addEventListener('change', ()=>{
      players[myIndex].color = myColorInput.value;
      gameRef.update({ players });
      draw();
    });

    // RESTART
    restartBtn.onclick = () => {
      if (mode==='local'){
        initializeGameState();
        turnIndex = 0;
        infoEl.textContent = `Turn: ${players[turnIndex].name}`;
      } else {
        gameRef.update({ lines: [], turnIndex:0 });
      }
    };

    // GAME LOGIC & DRAWING
    function initializeGameState(){
      // setup arrays
      nodes = Array.from({length:gridSize},()=>Array(gridSize).fill(false));
      horiz = Array.from({length:gridSize},()=>Array(gridSize-1).fill(false));
      vert  = Array.from({length:gridSize-1},()=>Array(gridSize).fill(false));
      cells = makeEmptyCells();
    }
    function isStraight3(sx,sy,ex,ey){
      const dx=Math.abs(ex-sx), dy=Math.abs(ey-sy);
      return (dx===3&&dy===0)||(dx===0&&dy===3);
    }
    function interior(sx,sy,ex,ey){
      if(sx===ex){
        const y0=Math.min(sy,ey);
        return [{x:sx,y:y0+1},{x:sx,y:y0+2}];
      } else {
        const x0=Math.min(sx,ex);
        return [{x:x0+1,y:sy},{x:x0+2,y:sy}];
      }
    }
    function noCross(sx,sy,ex,ey){
      const ni=interior(sx,sy,ex,ey);
      return !lines.some(ln=>
        interior(ln.sx,ln.sy,ln.ex,ln.ey)
          .some(a=>ni.some(b=>a.x===b.x&&a.y===b.y))
      );
    }
    function touches(sx,sy,ex,ey){
      return lines.length===0 || nodes[sy][sx] || nodes[ey][ex];
    }
    function occupyEdges(sx,sy,ex,ey,pIdx){
      lines.push({sx,sy,ex,ey,playerIndex:pIdx});
      if(sx===ex){
        const x=sx,y0=Math.min(sy,ey);
        for(let d=0;d<3;d++){
          vert[y0+d][x]=true;
          nodes[y0+d][x]=nodes[y0+d+1][x]=true;
        }
      } else {
        const y=sy,x0=Math.min(sx,ex);
        for(let d=0;d<3;d++){
          horiz[y][x0+d]=true;
          nodes[y][x0+d]=nodes[y][x0+d+1]=true;
        }
      }
    }
    function fillTerritories(pIdx){
      const visited=Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(false));
      const queue=[];
      for(let i=0;i<gridSize-1;i++){
        [[0,i],[gridSize-2,i],[i,0],[i,gridSize-2]].forEach(([x,y])=>{
          if(!visited[y][x]){visited[y][x]=true; queue.push({x,y});}
        });
      }
      const canPass=(x,y,nx,ny)=>
        x===nx ? !horiz[Math.min(y,ny)+1][x]
               : !vert [Math.min(x,nx)+1][y];
      while(queue.length){
        const {x,y}=queue.shift();
        [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
          const nx=x+dx, ny=y+dy;
          if(nx>=0&&nx<gridSize-1&&ny>=0&&ny<gridSize-1
             &&!visited[ny][nx]&&canPass(x,y,nx,ny)){
            visited[ny][nx]=true; queue.push({x:nx,y:ny});
          }
        });
      }
      for(let y=0;y<gridSize-1;y++){
        for(let x=0;x<gridSize-1;x++){
          if(!visited[y][x]&&cells[y][x]===0){
            cells[y][x]=pIdx+1;
          }
        }
      }
    }
    function computeStateFromLines(){
      initializeGameState();
      for(const ln of lines){
        occupyEdges(ln.sx,ln.sy,ln.ex,ln.ey,ln.playerIndex);
        fillTerritories(ln.playerIndex);
      }
    }
    function draw(){
      ctx.clearRect(0,0,420,420);
      // grid
      ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
      for(let i=0;i<=gridSize;i++){
        const p=g2px(i);
        ctx.beginPath();ctx.moveTo(p,0);ctx.lineTo(p,420);ctx.stroke();
        ctx.beginPath();ctx.moveTo(0,p);ctx.lineTo(420,p);ctx.stroke();
      }
      // cells
      for(let y=0;y<gridSize-1;y++){
        for(let x=0;x<gridSize-1;x++){
          const owner=cells[y][x];
          if(owner>0){
            ctx.globalAlpha=0.2;
            ctx.fillStyle=players[owner-1].color;
            ctx.fillRect(g2px(x),g2px(y),cellPx,cellPx);
            ctx.globalAlpha=1;
          }
        }
      }
      // lines
      for(const ln of lines){
        ctx.beginPath();
        ctx.lineWidth=4;
        ctx.strokeStyle=players[ln.playerIndex].color;
        ctx.moveTo(g2px(ln.sx),g2px(ln.sy));
        ctx.lineTo(g2px(ln.ex),g2px(ln.ey));
        ctx.stroke();
      }
    }

    // Canvas interaction
    let clickStart=null, hoverEnd=null;
    canvas.addEventListener('mousemove', e => {
      if(!clickStart) return;
      const r=canvas.getBoundingClientRect();
      hoverEnd={ x:px2g(e.clientX-r.left), y:px2g(e.clientY-r.top) };
      draw();
      // preview
      if(clickStart && hoverEnd){
        ctx.beginPath();
        ctx.setLineDash([5,5]);
        ctx.lineWidth=2;
        ctx.strokeStyle='gray';
        ctx.moveTo(g2px(clickStart.x),g2px(clickStart.y));
        ctx.lineTo(g2px(hoverEnd.x),g2px(hoverEnd.y));
        ctx.stroke();
        ctx.setLineDash([]);
      }
    });
    canvas.addEventListener('click', async e => {
      if (!started) return;
      const r=canvas.getBoundingClientRect();
      const gx=px2g(e.clientX-r.left), gy=px2g(e.clientY-r.top);
      if(!clickStart){
        clickStart={x:gx,y:gy};
        hoverEnd=null;
        return;
      }
      const sx=clickStart.x, sy=clickStart.y;
      const ex=(hoverEnd||{x:gx}).x, ey=(hoverEnd||{y:gy}).y;

      if(!isStraight3(sx,sy,ex,ey)){
        debugEl.textContent='Line must be straight & 3 cells long.';
      } else {
        computeStateFromLines();
        if(!touches(sx,sy,ex,ey)){
          debugEl.textContent='Must touch existing node.';
        } else if(!noCross(sx,sy,ex,ey)){
          debugEl.textContent='Line crosses another.';
        } else if (mode!=='local' && myIndex!==turnIndex){
          debugEl.textContent='Not your turn.';
        } else {
          debugEl.textContent='';
          if(mode==='local'){
            occupyEdges(sx,sy,ex,ey,turnIndex);
            fillTerritories(turnIndex);
            turnIndex=(turnIndex+1)%players.length;
            infoEl.textContent=`Turn: ${players[turnIndex].name}`;
            draw();
          } else {
            // submit to Firestore
            const newLines = [...lines, { sx,sy,ex,ey,playerIndex:turnIndex }];
            const next = (turnIndex+1)%players.length;
            await gameRef.update({ lines:newLines, turnIndex:next });
          }
        }
      }
      clickStart=hoverEnd=null;
      draw();
    });

  });
  </script>
</body>
</html>
