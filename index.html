<!--  Grid Territory – now peer‑to‑peer with NetplayJS  -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Grid Territory — online play (NetplayJS)</title>

<style>
  body,html{margin:0;padding:0;height:100%;font-family:sans-serif}
  #wrapper{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%}
  h2{margin:8px 0}
  #game-container{position:relative;width:420px;height:420px}
  canvas{position:absolute;top:0;left:0;background:#fff}
  #info{margin-top:8px;font-weight:600}
  #debug{margin-top:6px;font-size:.8em;color:#a00;white-space:pre-wrap}
  button{margin-top:12px;padding:8px 20px;font-size:1rem;cursor:pointer}
</style>
</head>
<body>
<div id="wrapper">
  <h2>Grid Territory (online two‑player)</h2>

  <div id="game-container">
    <canvas id="gameCanvas" width="420" height="420"></canvas>
  </div>

  <div id="info">Connecting…</div>
  <div id="debug"></div>
  <button id="restartBtn" disabled>Restart Game</button>
</div>

<!-- NetplayJS – public bundle -->
<script src="https://unpkg.com/netplayjs@0.4.1/dist/netplay.js"
        integrity="sha384-6Yb8LWAT488jwK+nIjvD4S5/poq1Xn69NYjH1RXKHoaUOaFJrKQ1rfGQgKm8oQjX"
        crossorigin="anonymous"></script>

<script>
/* ── Short helpers ─────────────────────────────────────────────── */
const $ = id => document.getElementById(id);
const gridSize = 21, cellPx = 20;
const px2g = px => Math.round(px / cellPx);
const g2px = g  => g * cellPx;

/* ── NetplayJS game class ──────────────────────────────────────── */
class GridTerritoryGame extends netplayjs.Game {

  /* --- static configuration for NetplayJS --- */
  static timestep   = 1000 / 60;          // 60 FPS
  static canvasSize = { width: 420, height: 420 };
  static numPlayers = { min: 2, max: 2 };

  constructor (canvas, players) {
    super();
    this.canvas = canvas;
    this.ctx    = canvas.getContext('2d');

    /* persistent state – autoserialised by NetplayJS  */
    this.turn  = 1;
    this.lines = [];
    this.nodes = Array.from({length:gridSize}, () => Array(gridSize    ).fill(false));
    this.horiz = Array.from({length:gridSize}, () => Array(gridSize-1 ).fill(false));
    this.vert  = Array.from({length:gridSize-1}, () => Array(gridSize ).fill(false));
    this.cells = Array.from({length:gridSize-1}, () => Array(gridSize-1).fill(0));

    /* transient, local‑only UI helpers (NOT serialised) */
    this.clickStart = null;
    this.hoverEnd   = null;

    /* attach mouse listeners on the local canvas */
    this._bindLocalPointer();
  }

  /* ---------- local pointer → input packets ---------- */
  _bindLocalPointer () {
    const rectOf = () => this.canvas.getBoundingClientRect();

    this.canvas.addEventListener('mousemove', e => {
      if (!this.clickStart) return;
      const r = rectOf();
      this.hoverEnd = {
        x: px2g(e.clientX - r.left),
        y: px2g(e.clientY - r.top)
      };
    });

    /* clicks become per‑frame LineInput objects sent via NetplayJS */
    this.canvas.addEventListener('click', e => {
      const r  = rectOf();
      const gx = px2g(e.clientX - r.left);
      const gy = px2g(e.clientY - r.top);

      /* first click = anchor node */
      if (!this.clickStart) {
        this.clickStart = { x: gx, y: gy };
        this.hoverEnd   = null;
        return;
      }

      /* second click forms the attempt  */
      const line = {
        sx: this.clickStart.x, sy: this.clickStart.y,
        ex: (this.hoverEnd || {x:gx}).x,
        ey: (this.hoverEnd || {y:gy}).y
      };

      /* enqueue for this frame – wrapper defined in bootstrap section */
      window.__wrapper.queueLocalInput(line);

      /* clear local drag */
      this.clickStart = this.hoverEnd = null;
    });
  }

  /* ---------- frame step – apply every player’s inputs ---------- */
  tick (playerInputs) {
    for (const [player, inp] of playerInputs.entries()) {
      if (!inp) continue;                 // player idle this frame
      const p = player.getID() === 0 ? 1 : 2;   // map to 1/2 labels

      if (this._isLegalLine(inp.sx, inp.sy, inp.ex, inp.ey)) {
        this._occupy(inp.sx, inp.sy, inp.ex, inp.ey, p);
        this.turn = this.turn === 1 ? 2 : 1;
      }
    }

    /* redraw every frame so both peers stay visually in‑sync */
    this.draw(this.canvas);
  }

  /* ---------- geometry & rules – lifted from original code ------- */
  _isStraight3 (sx,sy,ex,ey) {
    const dx = Math.abs(ex-sx), dy = Math.abs(ey-sy);
    return (dx===3&&dy===0)||(dx===0&&dy===3);
  }
  _interior (sx,sy,ex,ey){
    return sx===ex
      ? [{x:sx,y:Math.min(sy,ey)+1},{x:sx,y:Math.min(sy,ey)+2}]
      : [{x:Math.min(sx,ex)+1,y:sy},{x:Math.min(sx,ex)+2,y:sy}];
  }
  _noCross (sx,sy,ex,ey) {
    const ni = this._interior(sx,sy,ex,ey);
    return !this.lines.some(ln => this._interior(ln.sx,ln.sy,ln.ex,ln.ey)
      .some(a => ni.some(b => a.x===b.x && a.y===b.y)));
  }
  _touches (sx,sy,ex,ey){
    return this.lines.length===0 || this.nodes[sy][sx] || this.nodes[ey][ex];
  }
  _isLegalLine (sx,sy,ex,ey){
    return this._isStraight3(sx,sy,ex,ey) &&
           this._touches   (sx,sy,ex,ey) &&
           this._noCross   (sx,sy,ex,ey);
  }

  _occupy (sx,sy,ex,ey,p){
    this.lines.push({sx,sy,ex,ey,player:p});
    if (sx===ex){
      const x=sx,y0=Math.min(sy,ey);
      for(let d=0;d<3;d++){
        this.vert [y0+d][x]   = true;
        this.nodes[y0+d][x]   = true;
        this.nodes[y0+d+1][x] = true;
      }
    } else {
      const y=sy,x0=Math.min(sx,ex);
      for(let d=0;d<3;d++){
        this.horiz[y][x0+d]   = true;
        this.nodes[y][x0+d]   = true;
        this.nodes[y][x0+1+d] = true;
      }
    }
    this._fillTerritories(p);
  }

  _fillTerritories (p){
    const visited = Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(false));
    const q = [];
    for (let i=0;i<gridSize-1;i++)
      [[0,i],[gridSize-2,i],[i,0],[i,gridSize-2]]
      .forEach(([x,y])=>{ if(!visited[y][x]){ visited[y][x]=true; q.push({x,y}); } });

    const pass = (x,y,nx,ny) => x===nx
        ? !this.horiz[Math.min(y,ny)+1][x]
        : !this.vert [y][Math.min(x,nx)+1];

    while(q.length){
      const {x,y} = q.shift();
      [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
         const nx=x+dx, ny=y+dy;
         if (nx>=0 && nx<gridSize-1 && ny>=0 && ny<gridSize-1 &&
             !visited[ny][nx] && pass(x,y,nx,ny)){
           visited[ny][nx] = true; q.push({x:nx,y:ny});
         }
      });
    }
    for(let y=0;y<gridSize-1;y++)
      for(let x=0;x<gridSize-1;x++)
        if(!visited[y][x] && this.cells[y][x]===0) this.cells[y][x] = p;
  }

  /* ---------- drawing – same as the original, plus drag preview ---- */
  draw () {
    const ctx = this.ctx;
    ctx.clearRect(0,0,420,420);

    /* grid */
    ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
    for (let i=0;i<=gridSize;i++){
      const p=g2px(i);
      ctx.beginPath(); ctx.moveTo(p,0);   ctx.lineTo(p,420); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p);   ctx.lineTo(420,p); ctx.stroke();
    }

    /* filled cells */
    for (let y=0;y<gridSize-1;y++)
      for (let x=0;x<gridSize-1;x++)
        if (this.cells[y][x]>0){
          ctx.globalAlpha=.2;
          ctx.fillStyle=this.cells[y][x]==1?'red':'blue';
          ctx.fillRect(g2px(x),g2px(y),cellPx,cellPx);
          ctx.globalAlpha=1;
        }

    /* lines */
    for (const ln of this.lines){
      ctx.beginPath();
      ctx.lineWidth=4;
      ctx.strokeStyle=ln.player==1?'red':'blue';
      ctx.moveTo(g2px(ln.sx),g2px(ln.sy));
      ctx.lineTo(g2px(ln.ex),g2px(ln.ey));
      ctx.stroke();
    }

    /* local drag preview */
    if (this.clickStart && this.hoverEnd){
      ctx.beginPath();
      ctx.setLineDash([5,5]);
      ctx.lineWidth=2;
      ctx.strokeStyle='gray';
      ctx.moveTo(g2px(this.clickStart.x),g2px(this.clickStart.y));
      ctx.lineTo(g2px(this.hoverEnd.x),g2px(this.hoverEnd.y));
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }
}

/* ── Bootstrapping the wrapper & simple status UI ─────────────── */
window.addEventListener('DOMContentLoaded', () => {

  const wrapper = new netplayjs.RollbackWrapper(GridTerritoryGame);
  window.__wrapper = wrapper;                // expose for queueLocalInput
  wrapper.start();

  /* update little status banner */
  const info = $('info'), dbg=$('debug'), restartBtn=$('restartBtn');

  wrapper.on('connected', () => {
    info.textContent = 'Both players connected – Player 1 begins!';
    restartBtn.disabled = false;
  });

  /* custom debug helper so both sides see rule violations */
  wrapper.on('exception', e => { dbg.textContent = e.message || e; });

  restartBtn.onclick = () => { wrapper.restart(); dbg.textContent=''; };
});
</script>
</body>
</html>
