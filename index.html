<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Grid Territory‚ÄÇ‚Äì‚ÄÇLocal & P2P</title>
  <style>
    body,html{margin:0;padding:0;height:100%;font-family:sans-serif}
    #menu {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      height:100%;
    }
    button{margin:8px;padding:12px 24px;font-size:1.2rem;cursor:pointer;}
    #game-container{position:relative;width:420px;height:420px;margin:auto;display:none}
    canvas{background:#fff;display:block}
    #info{margin-top:8px;text-align:center;font-weight:600}
    #debug{margin-top:8px;font-size:.9em;color:#a00;white-space:pre-wrap;text-align:center}
  </style>

  <!-- NetplayJS: P2P + rollback netcode in one script -->
  <script 
    src="https://unpkg.com/netplayjs@0.4.1/dist/netplay.js" 
    integrity="sha384-6Yb8LWAT488jwK+nIjvD4S5/poq1Xn69NYjH1RXKHoaUOaFJrKQ1rfGQgKm8oQjX" 
    crossorigin="anonymous">
  </script><!-- :contentReference[oaicite:0]{index=0} -->
</head>
<body>
  <!-- MENU -->
  <div id="menu">
    <h2>Grid Territory</h2>
    <button id="localBtn">‚ñ∂ Local Play</button>
    <button id="multiBtn">üåê Multiplayer</button>
  </div>

  <!-- SHARED GAME CONTAINER -->
  <div id="game-container">
    <canvas id="gameCanvas" width="420" height="420"></canvas>
    <div id="info"></div>
    <div id="debug"></div>
  </div>

  <script>
  (function(){
    const gridSize = 21, cellPx = 20;

    // ‚îÄ‚îÄ Original helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const isStraight3 = (sx,sy,ex,ey) => {
      const dx=Math.abs(ex-sx), dy=Math.abs(ey-sy);
      return (dx===3&&dy===0)||(dx===0&&dy===3);
    };
    const interior = (sx,sy,ex,ey) => sx===ex
      ? [{x:sx,y:Math.min(sy,ey)+1},{x:sx,y:Math.min(sy,ey)+2}]
      : [{x:Math.min(sx,ex)+1,y:sy},{x:Math.min(sx,ex)+2,y:sy}];

    function noCross(lines, sx,sy,ex,ey){
      const ni = interior(sx,sy,ex,ey);
      return !lines.some(ln=>
        interior(ln.sx,ln.sy,ln.ex,ln.ey)
          .some(a=>ni.some(b=>a.x===b.x&&a.y===b.y))
      );
    }
    function touches(nodes, sx,sy,ex,ey){
      return nodes[sy][sx] || nodes[ey][ex];
    }

    // ‚îÄ‚îÄ Game class for NetplayJS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    class GridTerritoryGame extends netplayjs.Game {
      // 60 FPS, matching your original draw rate
      static timestep = 1000/60;
      static canvasSize = { width: 420, height: 420 };

      constructor(canvas, players){
        super(canvas, players);
        this.ctx = canvas.getContext('2d');
        this._resetState();
      }

      // Reset or initialize all game state
      _resetState(){
        this.turn = 1;
        this.lines = [];
        this.nodes = Array.from({length:gridSize},()=>Array(gridSize).fill(false));
        this.horiz = Array.from({length:gridSize},()=>Array(gridSize-1).fill(false));
        this.vert  = Array.from({length:gridSize-1},()=>Array(gridSize).fill(false));
        this.cells = Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(0));
        this.clickStart = null;
        this.hoverEnd = null;
        this.infoMsg = 'Turn: Player 1';
        this.debugMsg = '';
      }

      // Override Game.serialize so NetplayJS can snapshot & rewind
      serialize(){
        return {
          turn: this.turn,
          lines: this.lines,
          nodes: this.nodes,
          horiz: this.horiz,
          vert: this.vert,
          cells: this.cells
        };
      }
      // And restore
      deserialize(state){
        Object.assign(this, {
          turn: state.turn,
          lines: state.lines,
          nodes: state.nodes,
          horiz: state.horiz,
          vert: state.vert,
          cells: state.cells
        });
      }

      // Called each net-tick with a Map<Player, DefaultInput>
      tick(playerInputs){
        // Only the player whose turn it is may place a line
        const activeID = this.turn - 1;
        for (const [player, input] of playerInputs.entries()){
          if (player.getID() !== activeID) continue;

          // DefaultInput captures mouse events automatically.
          // Here we check for *new* clicks this frame.
          // The API is input.getEvents(); each event = {type, x, y}.
          // (Consult your version of NetplayJS for exact names.)
          const evts = input.getEvents?.() || [];
          evts.forEach(e=>{
            const gx = Math.round(e.x / cellPx);
            const gy = Math.round(e.y / cellPx);

            if (e.type === 'pointerdown') {
              this.clickStart = {x: gx, y: gy};
              this.hoverEnd = null;
            }
            if (e.type === 'pointerup' && this.clickStart) {
              this.hoverEnd = {x: gx, y: gy};
              const {x:sx,y:sy} = this.clickStart;
              const {x:ex,y:ey} = this.hoverEnd;

              // Validate & occupy
              if (!isStraight3(sx,sy,ex,ey)) {
                this.debugMsg = 'Line must be straight & 3 cells long.';
              } else if (!touches(this.nodes, sx,sy,ex,ey) && this.lines.length>0){
                this.debugMsg = 'Line must touch an existing node.';
              } else if (!noCross(this.lines, sx,sy,ex,ey)){
                this.debugMsg = 'Line would illegally cross another.';
              } else {
                // occupy
                this.lines.push({sx,sy,ex,ey,player:this.turn});
                if (sx===ex){
                  const x=sx, y0=Math.min(sy,ey);
                  for(let d=0;d<3;d++){
                    this.vert[y0+d][x]=true;
                    this.nodes[y0+d][x]=this.nodes[y0+d+1][x]=true;
                  }
                } else {
                  const y=sy, x0=Math.min(sx,ex);
                  for(let d=0;d<3;d++){
                    this.horiz[y][x0+d]=true;
                    this.nodes[y][x0+d]=this.nodes[y][x0+1+d]=true;
                  }
                }
                // fill territories
                this._fillTerritories(this.turn);
                // next turn
                this.turn = this.turn===1?2:1;
                this.infoMsg = 'Turn: Player ' + this.turn;
                this.debugMsg = '';
              }
              this.clickStart = this.hoverEnd = null;
            }
          });
        }
      }

      // Territory flood-fill, same as original
      _fillTerritories(p){
        const visited = Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(false));
        const q = [];
        for(let i=0;i<gridSize-1;i++){
          [[0,i],[gridSize-2,i],[i,0],[i,gridSize-2]]
            .forEach(([x,y])=>{
              if(!visited[y][x]){
                visited[y][x]=true;
                q.push({x,y});
              }
            });
        }
        const pass = (x,y,nx,ny)=>
          x===nx
            ? !this.horiz[Math.min(y,ny)+1][x]
            : !this.vert[y][Math.min(x,nx)+1];
        while(q.length){
          const {x,y}=q.shift();
          [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
            const nx=x+dx, ny=y+dy;
            if (nx>=0&&nx<gridSize-1&&ny>=0&&ny<gridSize-1
                && !visited[ny][nx] && pass(x,y,nx,ny)) {
              visited[ny][nx]=true;
              q.push({x:nx,y:ny});
            }
          });
        }
        for(let y=0;y<gridSize-1;y++){
          for(let x=0;x<gridSize-1;x++){
            if(!visited[y][x] && this.cells[y][x]===0){
              this.cells[y][x] = p;
            }
          }
        }
      }

      // Draw full grid, cells, lines, and preview
      draw(canvas){
        const ctx = this.ctx;
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // Grid
        ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
        for(let i=0;i<=gridSize;i++){
          const p=i*cellPx;
          ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,420); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(420,p); ctx.stroke();
        }

        // Filled cells
        for(let y=0;y<gridSize-1;y++){
          for(let x=0;x<gridSize-1;x++){
            if(this.cells[y][x]>0){
              ctx.globalAlpha=0.2;
              ctx.fillStyle = this.cells[y][x]==1?'red':'blue';
              ctx.fillRect(x*cellPx,y*cellPx,cellPx,cellPx);
              ctx.globalAlpha=1;
            }
          }
        }

        // Draw lines
        this.lines.forEach(ln=>{
          ctx.beginPath();
          ctx.lineWidth=4;
          ctx.strokeStyle=ln.player==1?'red':'blue';
          ctx.moveTo(ln.sx*cellPx,ln.sy*cellPx);
          ctx.lineTo(ln.ex*cellPx,ln.ey*cellPx);
          ctx.stroke();
        });

        // Preview (if any)
        if(this.clickStart && this.hoverEnd){
          ctx.beginPath();
          ctx.setLineDash([5,5]);
          ctx.lineWidth=2;
          ctx.strokeStyle='gray';
          ctx.moveTo(this.clickStart.x*cellPx, this.clickStart.y*cellPx);
          ctx.lineTo(this.hoverEnd.x*cellPx, this.hoverEnd.y*cellPx);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Info & debug
        document.getElementById('info').textContent = this.infoMsg;
        document.getElementById('debug').textContent = this.debugMsg;
      }
    } // end of Game class

    // ‚îÄ‚îÄ UI & Mode switching ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const menu    = document.getElementById('menu');
    const gcont   = document.getElementById('game-container');
    const localBtn  = document.getElementById('localBtn');
    const multiBtn  = document.getElementById('multiBtn');

    // LOCAL PLAY: exactly your original code
    function startLocal(){
      menu.style.display = 'none';
      gcont.style.display = '';
      // reuse your old initGameState()
      initGameState();
    }

    // P2P MULTIPLAYER
    function startMulti(){
      menu.style.display = 'none';
      gcont.style.display = '';
      // This will handle matchmaking, shareable URL, rollback netcode‚Ä¶ :contentReference[oaicite:1]{index=1}
      new netplayjs.RollbackWrapper(GridTerritoryGame).start();
    }

    localBtn .onclick = startLocal;
    multiBtn .onclick = startMulti;

    // ‚îÄ‚îÄ Your original local two-player logic ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const canvas = document.getElementById('gameCanvas');
    const ctx    = canvas.getContext('2d');
    let turn, lines, nodes, horiz, vert, cells, clickStart, hoverEnd;

    function initGameState(){
      turn = 1;
      lines = [];
      nodes = Array.from({length:gridSize},()=>Array(gridSize).fill(false));
      horiz = Array.from({length:gridSize},()=>Array(gridSize-1).fill(false));
      vert  = Array.from({length:gridSize-1},()=>Array(gridSize).fill(false));
      cells = Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(0));
      clickStart = hoverEnd = null;
      document.getElementById('debug').textContent = '';
      document.getElementById('info').textContent  = 'Turn: Player 1';
      draw();
    }

    function occupy(sx,sy,ex,ey,p){
      lines.push({sx,sy,ex,ey,player:p});
      if(sx===ex){
        const x=sx,y0=Math.min(sy,ey);
        for(let d=0;d<3;d++){
          vert[y0+d][x]=true;
          nodes[y0+d][x]=nodes[y0+d+1][x]=true;
        }
      } else {
        const y=sy,x0=Math.min(sx,ex);
        for(let d=0;d<3;d++){
          horiz[y][x0+d]=true;
          nodes[y][x0+d]=nodes[y][x0+1+d]=true;
        }
      }
      // reuse fillTerritories from above (minor tweak)
      GridTerritoryGame.prototype._fillTerritories.call({cells, horiz, vert, nodes, lines}, p);
    }

    function draw(){
      // reuse draw code from class, but here simpler:
      ctx.clearRect(0,0,420,420);
      // ‚Ä¶ (same as in class.draw) ‚Ä¶
      // for brevity, assume you copy-paste your original draw()
      GridTerritoryGame.prototype.draw.call({ctx, lines, cells, clickStart, hoverEnd}, canvas);
    }

    canvas.addEventListener('mousemove',e=>{
      if(!clickStart) return;
      const r=canvas.getBoundingClientRect();
      hoverEnd = {
        x: Math.round((e.clientX - r.left)/cellPx),
        y: Math.round((e.clientY - r.top )/cellPx)
      };
      draw();
    });
    canvas.addEventListener('click',e=>{
      const r=canvas.getBoundingClientRect();
      const gx = Math.round((e.clientX - r.left)/cellPx);
      const gy = Math.round((e.clientY - r.top )/cellPx);
      if(!clickStart){
        clickStart={x:gx,y:gy}; hoverEnd=null; return;
      }
      const {x:sx,y:sy} = clickStart;
      const ex = gx, ey = gy;
      if(!isStraight3(sx,sy,ex,ey)){
        document.getElementById('debug').textContent = 'Line must be straight and exactly 3 cells long.';
      } else if(!touches(nodes,sx,sy,ex,ey)){
        document.getElementById('debug').textContent = 'Line must touch an existing node.';
      } else if(!noCross(lines,sx,sy,ex,ey)){
        document.getElementById('debug').textContent = 'Line would illegally cross another.';
      } else {
        occupy(sx,sy,ex,ey,turn);
        turn = turn===1?2:1;
        document.getElementById('info').textContent = 'Turn: Player ' + turn;
        document.getElementById('debug').textContent = '';
      }
      clickStart = hoverEnd = null;
      draw();
    });

    // kick off in menu mode
  })();
  </script>
</body>
</html>
