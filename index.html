<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Grid Territory Multiplayer</title>
  <style>
    body,html { margin:0; padding:0; height:100%; font-family:sans-serif; }
    /* Overlays */
    #setupOverlay, #lobbyOverlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(255,255,255,0.95);
      display:flex; align-items:center; justify-content:center; z-index:10;
    }
    .dialog {
      background:#fff; padding:20px; border:1px solid #ccc; border-radius:4px;
      max-width:400px; width:100%;
    }
    .player-row { display:flex; align-items:center; margin-bottom:8px; }
    .player-row label { flex:1; }
    /* Main game */
    #wrapper { display:none; height:100%; flex-direction:column; }
    #wrapper.flex { display:flex; }
    #main { display:flex; flex:1; }
    #game-container { position:relative; width:420px; height:420px; }
    canvas { position:absolute; top:0; left:0; background:#fff; }
    #sidebar { margin-left:20px; width:200px; }
    #chatLog { overflow-y:auto; height:200px; border:1px solid #ccc; padding:5px; }
    #info { margin-top:8px; font-weight:600; }
    #debug { margin-top:8px; font-size:.8em; color:#a00; white-space:pre-wrap; }
    button { margin-top:8px; padding:6px 12px; font-size:.9rem; cursor:pointer; }
    select,input[type="text"] { width:100%; padding:4px; box-sizing:border-box; }
  </style>

  <!-- Firebase UMD (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore-compat.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCfKDzCpj9KfQ_aglBZ1pHmtkD-XNKs8Gc",
      authDomain: "territory-game-860e8.firebaseapp.com",
      projectId: "territory-game-860e8",
      storageBucket: "territory-game-860e8.firebasestorage.app",
      messagingSenderId: "797594052134",
      appId: "1:797594052134:web:d452b45cdf98b9164de8e7",
      measurementId: "G-28RC8M9MKP"
    };
    firebase.initializeApp(firebaseConfig);
  </script>
</head>
<body>
  <!-- 1) Setup -->
  <div id="setupOverlay">
    <div class="dialog">
      <h3>Setup Game</h3>
      <label><input type="radio" name="mode" value="local" checked> Local</label>
      <label><input type="radio" name="mode" value="host"> Host Online</label>
      <label><input type="radio" name="mode" value="join"> Join Online</label>
      <div id="hostConfig">
        <br/>
        <label>Players: <input type="number" id="playerCount" min="2" max="8" value="2"/></label>
      </div>
      <div id="joinConfig" style="display:none;">
        <br/>
        <input id="joinGameId" type="text" placeholder="Enter Game ID to join"/>
      </div>
      <button id="startBtn">Next →</button>
    </div>
  </div>

  <!-- 2) Lobby -->
  <div id="lobbyOverlay" style="display:none;">
    <div class="dialog">
      <h3>Game Lobby</h3>
      <p>Game ID: <strong id="lobbyGameId"></strong></p>
      <p>Players (<span id="joinedCount">0</span>/<span id="maxPlayersDisplay">0</span>):</p>
      <div id="lobbyPlayersList"></div>
      <hr/>
      <h4>You</h4>
      <div class="player-row">
        <label>Name: <input id="myName" type="text"/></label>
      </div>
      <div class="player-row">
        <label>Color:
          <select id="myColor">
            <option value="#006400">darkgreen</option>
            <option value="#ff0000">red</option>
            <option value="#ffd700">gold</option>
            <option value="#c71585">mediumvioletred</option>
            <option value="#00ff00">lime</option>
            <option value="#00ffff">aqua</option>
            <option value="#0000ff">blue</option>
            <option value="#1e90ff">dodgerblue</option>
          </select>
        </label>
      </div>
      <button id="readyBtn">Ready</button>
      <button id="hostStartBtn" style="display:none;">Start Game</button>
    </div>
  </div>

  <!-- 3) Main Game UI -->
  <div id="wrapper">
    <h2>Grid Territory</h2>
    <div id="main">
      <div id="game-container">
        <canvas id="gameCanvas" width="420" height="420"></canvas>
      </div>
      <div id="sidebar">
        <div id="chatSection" style="display:none;">
          <h4>Chat</h4>
          <div id="chatLog"></div>
          <input id="chatInput" type="text" placeholder="Type message..."/>
          <button id="chatSendBtn">Send</button>
        </div>
      </div>
    </div>
    <div id="info">Waiting…</div>
    <div id="debug"></div>
    <button id="restartBtn">Restart Game</button>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const $ = id => document.getElementById(id);
    const clientId = Math.random().toString(36).substr(2,9);

    let mode, maxPlayers, myIndex, gameRef, started=false;
    let players=[], lines=[], chat=[], turnIndex=0;
    const db = firebase.firestore();

    // UI refs
    const modeRadios    = document.getElementsByName('mode'),
          hostConfig    = $('hostConfig'),
          joinConfig    = $('joinConfig'),
          playerCountIn = $('playerCount'),
          joinGameId    = $('joinGameId'),
          startBtn      = $('startBtn'),
          setupOverlay  = $('setupOverlay'),
          lobbyOverlay  = $('lobbyOverlay'),
          lobbyGameIdEl = $('lobbyGameId'),
          maxPlayersEl  = $('maxPlayersDisplay'),
          joinedCountEl = $('joinedCount'),
          lobbyList     = $('lobbyPlayersList'),
          myNameInput   = $('myName'),
          myColorSelect = $('myColor'),
          readyBtn      = $('readyBtn'),
          hostStartBtn  = $('hostStartBtn'),
          wrapper       = $('wrapper'),
          chatSection   = $('chatSection'),
          chatLog       = $('chatLog'),
          chatInput     = $('chatInput'),
          chatSendBtn   = $('chatSendBtn'),
          infoEl        = $('info'),
          debugEl       = $('debug'),
          restartBtn    = $('restartBtn'),
          canvas        = $('gameCanvas'),
          ctx           = canvas.getContext('2d');

    // Grid state
    const gridSize = 21, cellPx = 20;
    let nodes, interiorNodes, horiz, vert, cells;

    function makeEmptyCells(){
      return Array.from({length:gridSize-1}, ()=>Array(gridSize-1).fill(0));
    }
    function initializeGame(){
      nodes = Array.from({length:gridSize}, ()=>Array(gridSize).fill(false));
      interiorNodes = Array.from({length:gridSize}, ()=>Array(gridSize).fill(false));
      horiz = Array.from({length:gridSize}, ()=>Array(gridSize-1).fill(false));
      vert  = Array.from({length:gridSize-1}, ()=>Array(gridSize).fill(false));
      cells = makeEmptyCells();
    }
    function computeState(){
      initializeGame();
      lines.forEach(ln => occupy(ln.sx,ln.sy,ln.ex,ln.ey,ln.playerIndex));
    }

    // Snap px→grid, CLAMPED to [0, gridSize-1]
    function px2g(px){
      const g = Math.floor((px + cellPx/2)/cellPx);
      return Math.min(Math.max(g, 0), gridSize-1);
    }
    function g2px(g){ return g*cellPx; }

    // Interior dots
    function getInterior(sx,sy,ex,ey){
      return [
        { x: sx + (ex-sx)/3,   y: sy + (ey-sy)/3   },
        { x: sx + 2*(ex-sx)/3, y: sy + 2*(ey-sy)/3 }
      ];
    }

    // Core occupy
    function _occupy(sx,sy,ex,ey,p){
      if(sx===ex){
        const x=sx, y0=Math.min(sy,ey);
        for(let d=0;d<3;d++) vert[y0+d][x]=true;
      } else {
        const y=sy, x0=Math.min(sx,ex);
        for(let d=0;d<3;d++) horiz[y][x0+d]=true;
      }
      const all = [{x:sx,y:sy},{x:ex,y:ey},...getInterior(sx,sy,ex,ey)];
      all.forEach(pt=> nodes[pt.y][pt.x]=true );
      getInterior(sx,sy,ex,ey).forEach(pt=> interiorNodes[pt.y][pt.x]=true);
      fillTerritories(p);
    }
    function occupy(sx,sy,ex,ey,p){
      if(mode==='local') lines.push({sx,sy,ex,ey,playerIndex:p});
      _occupy(sx,sy,ex,ey,p);
    }

    // Flood-fill
    function fillTerritories(player){
      const visited = Array.from({length:gridSize-1}, ()=>Array(gridSize-1).fill(false));
      const queue = [];
      for(let i=0;i<gridSize-1;i++){
        [[0,i],[gridSize-2,i],[i,0],[i,gridSize-2]].forEach(([x,y])=>{
          if(!visited[y][x]){
            visited[y][x]=true;
            queue.push({x,y});
          }
        });
      }
      const canPass = (x,y,nx,ny) =>
        x===nx
          ? !horiz[Math.min(y,ny)+1][x]
          : !vert[y][Math.min(x,nx)+1];

      while(queue.length){
        const {x,y} = queue.shift();
        [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
          const nx=x+dx, ny=y+dy;
          if(
            nx>=0&&nx<gridSize-1&&
            ny>=0&&ny<gridSize-1&&
            !visited[ny][nx]&&
            canPass(x,y,nx,ny)
          ){
            visited[ny][nx]=true;
            queue.push({x:nx,y:ny});
          }
        });
      }
      for(let y=0;y<gridSize-1;y++){
        for(let x=0;x<gridSize-1;x++){
          if(!visited[y][x] && cells[y][x]===0){
            cells[y][x]=player+1;
          }
        }
      }
    }

    // Validators
    function isStraight3(sx,sy,ex,ey){
      const dx=Math.abs(ex-sx), dy=Math.abs(ey-sy);
      return (dx===3&&dy===0)||(dx===0&&dy===3);
    }
    function noNodeReuse(sx,sy,ex,ey){
      return getInterior(sx,sy,ex,ey)
        .every(pt=>!interiorNodes[pt.y][pt.x]);
    }
    function noTerritory(sx,sy,ex,ey){
      // unchanged logic, but with valid indices now
      if(sx===ex){
        const x=sx, y0=Math.min(sy,ey);
        for(let d=0;d<3;d++){
          const y=y0+d;
          if((x-1>=0&&cells[y][x-1]!==0)||(x<gridSize-1&&cells[y][x]!==0))
            return false;
        }
      } else {
        const y=sy, x0=Math.min(sx,ex);
        for(let d=0;d<3;d++){
          const x=x0+d;
          if((y-1>=0&&cells[y-1][x]!==0)||(y<gridSize-1&&cells[y][x]!==0))
            return false;
        }
      }
      return true;
    }

    // NEW: forbid mutual end‐to‐midpoint touches
    function noMutualTouch(sx,sy,ex,ey){
      const newEnds = [{x:sx,y:sy},{x:ex,y:ey}];
      const newMids = getInterior(sx,sy,ex,ey);
      for(const ln of lines){
        const extEnds = [{x:ln.sx,y:ln.sy},{x:ln.ex,y:ln.ey}];
        const extMids = getInterior(ln.sx,ln.sy,ln.ex,ln.ey);
        const endTouchesMid = extMids.some(em =>
          newEnds.some(ne => ne.x===em.x && ne.y===em.y)
        );
        const midTouchesEnd = newMids.some(nm =>
          extEnds.some(ee => ee.x===nm.x && ee.y===nm.y)
        );
        if(endTouchesMid && midTouchesEnd){
          return false;
        }
      }
      return true;
    }

    function isConnected(sx,sy,ex,ey){
      if(!lines.length) return true;
      const pts = [{x:sx,y:sy},{x:ex,y:ey},...getInterior(sx,sy,ex,ey)];
      return pts.some(pt=>nodes[pt.y][pt.x]);
    }

    // Draw
    function draw(){
      ctx.clearRect(0,0,420,420);
      ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
      for(let i=0;i<=gridSize;i++){
        const p=g2px(i);
        ctx.beginPath(); ctx.moveTo(p,0);    ctx.lineTo(p,420); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p);    ctx.lineTo(420,p); ctx.stroke();
      }
      // territories
      for(let y=0;y<gridSize-1;y++){
        for(let x=0;x<gridSize-1;x++){
          const o=cells[y][x];
          if(o>0){
            ctx.globalAlpha=0.2;
            ctx.fillStyle=players[o-1].color;
            ctx.fillRect(g2px(x),g2px(y),cellPx,cellPx);
            ctx.globalAlpha=1;
          }
        }
      }
      // lines
      lines.forEach(ln=>{
        ctx.beginPath();
        ctx.lineWidth=4;
        ctx.strokeStyle=players[ln.playerIndex].color;
        ctx.moveTo(g2px(ln.sx),g2px(ln.sy));
        ctx.lineTo(g2px(ln.ex),g2px(ln.ey));
        ctx.stroke();
      });
      // preview
      if(clickStart && hoverEnd){
        ctx.beginPath();
        ctx.setLineDash([5,5]);
        ctx.lineWidth=2;
        ctx.strokeStyle='gray';
        ctx.moveTo(g2px(clickStart.x),g2px(clickStart.y));
        ctx.lineTo(g2px(hoverEnd.x),g2px(hoverEnd.y));
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Update the info bar with turn + territory counts
    function updateInfo(){
      const counts = players.map(() => 0);
      cells.forEach(row =>
        row.forEach(c =>
          c>0 && counts[c-1]++
        )
      );
      let text = `Turn: ${players[turnIndex].name}`;
      const parts = players.map((p,i)=>`${p.name}: ${counts[i]}`);
      text += ' | Territories: ' + parts.join(', ');
      infoEl.textContent = text;
    }

    // Setup & lobby logic
    function updateConfig(){
      mode = document.querySelector('input[name=mode]:checked').value;
      hostConfig.style.display = mode!=='join' ? 'block' : 'none';
      joinConfig.style.display = mode==='join'   ? 'block' : 'none';
    }
    modeRadios.forEach(r=>r.addEventListener('change', updateConfig));
    updateConfig();

    startBtn.onclick = () => {
      mode = document.querySelector('input[name=mode]:checked').value;
      if(mode==='local'){
        maxPlayers = +playerCountIn.value; players=[];
        for(let i=0;i<maxPlayers;i++){
          players.push({
            id:null,
            name:`Player ${i+1}`,
            color:['#006400','#ff0000','#ffd700','#c71585','#00ff00','#00ffff','#0000ff','#1e90ff'][i],
            ready:true
          });
        }
        lines=[]; setupOverlay.style.display='none'; startLocal();
      } else {
        maxPlayers = +playerCountIn.value;
        const gid = mode==='host'
          ? (()=>{ const id=Math.random().toString(36).substr(2,9);
                    history.replaceState(null,'','?game='+id);
                    return id; })()
          : joinGameId.value.trim();
        if(mode==='join' && !gid) return alert('Enter Game ID');
        setupOverlay.style.display='none';
        lobbyOverlay.style.display='flex';
        lobbyGameIdEl.textContent = gid;
        maxPlayersEl.textContent  = maxPlayers;
        initOnline(gid, mode==='host');
      }
    };

    function startLocal(){
      initializeGame(); computeState(); draw(); updateInfo();
      wrapper.style.display='flex'; wrapper.classList.add('flex');
    }

    async function initOnline(gameId,isHost){
      gameRef = db.collection('games').doc(gameId);
      if(isHost){
        players=[{id:clientId,name:'Player 1',color:'#006400',ready:false}];
        await gameRef.set({
          maxPlayers, players, turnIndex:0,
          lines:[], chat:[], started:false
        });
      } else {
        const snap = await gameRef.get();
        if(!snap.exists) return alert('Game not found');
        const data = snap.data();
        if(data.players.length>=data.maxPlayers) return alert('Game is full');
        players = data.players;
        players.push({
          id:clientId,
          name:`Player ${players.length+1}`,
          color:['#006400','#ff0000','#ffd700','#c71585','#00ff00','#00ffff','#0000ff','#1e90ff'][players.length],
          ready:false
        });
        await gameRef.update({players});
      }
      gameRef.onSnapshot(doc=>handleSnapshot(doc.data(),isHost));
    }

    function handleSnapshot(data,isHost){
      players    = data.players;
      lines      = data.lines;
      chat       = data.chat;
      turnIndex  = data.turnIndex;
      maxPlayers = data.maxPlayers;
      started    = data.started;
      myIndex    = players.findIndex(p=>p.id===clientId);

      if(!started){
        joinedCountEl.textContent=players.length;
        lobbyList.innerHTML='';
        players.forEach(p=>{
          const div=document.createElement('div');
          const sw=document.createElement('span');
          sw.style.cssText='display:inline-block;width:12px;height:12px;margin-right:5px;background:'+p.color;
          div.append(sw,p.name+(p.ready?' (Ready)':''));
          lobbyList.append(div);
        });
        myNameInput.value      = players[myIndex].name;
        myColorSelect.value    = players[myIndex].color;
        myNameInput.disabled   = false;
        myColorSelect.disabled = false;
        readyBtn.disabled      = false;
        readyBtn.textContent   = players[myIndex].ready?'Unready':'Ready';
        if(isHost){
          hostStartBtn.style.display='inline-block';
          hostStartBtn.disabled = !(players.length===maxPlayers&&players.every(x=>x.ready));
        } else {
          hostStartBtn.style.display='none';
        }
      } else {
        lobbyOverlay.style.display='none';
        wrapper.style.display='flex'; wrapper.classList.add('flex');
        chatSection.style.display='block';
        initializeGame(); computeState(); draw(); renderChat(); updateInfo();
      }
    }

    // lobby & chat handlers
    readyBtn.onclick      = ()=>{ players[myIndex].ready=!players[myIndex].ready; gameRef.update({players}); };
    hostStartBtn.onclick  = ()=>gameRef.update({started:true});
    myNameInput.onchange  = ()=>{ players[myIndex].name=myNameInput.value;   gameRef.update({players}); };
    myColorSelect.onchange= ()=>{ players[myIndex].color=myColorSelect.value; gameRef.update({players}); };

    chatSendBtn.onclick = ()=>{ 
      const t=chatInput.value.trim(); if(!t) return;
      const m={senderId:clientId,senderName:players[myIndex].name,text:t,timestamp:Date.now()};
      gameRef.update({chat:firebase.firestore.FieldValue.arrayUnion(m)});
      chatInput.value='';
    };
    function renderChat(){
      chatLog.innerHTML='';
      chat.sort((a,b)=>a.timestamp-b.timestamp).forEach(m=>{
        const d=document.createElement('div');
        d.innerHTML=`<strong>${m.senderName}</strong> [${new Date(m.timestamp).toLocaleTimeString()}]: ${m.text}`;
        chatLog.append(d);
      });
      chatLog.scrollTop=chatLog.scrollHeight;
    }

    // Restart
    restartBtn.onclick = ()=>{
      if(mode==='local'){
        lines=[]; turnIndex=0;
        initializeGame(); computeState(); draw(); updateInfo();
      } else {
        gameRef.update({lines:[],turnIndex:0});
      }
    };

    // Mouse events
    let clickStart=null, hoverEnd=null;
    canvas.addEventListener('mousemove', e=>{
      if(!clickStart) return;
      const r=canvas.getBoundingClientRect();
      hoverEnd={x:px2g(e.clientX-r.left),y:px2g(e.clientY-r.top)};
      draw();
    });
    canvas.addEventListener('click', async e=>{
      if(mode!=='local' && !started) return;
      if(mode!=='local' && turnIndex!==myIndex){
        debugEl.textContent='Not your turn.'; clickStart=hoverEnd=null; return;
      }
      const r=canvas.getBoundingClientRect();
      const gx=px2g(e.clientX-r.left), gy=px2g(e.clientY-r.top);
      if(!clickStart){
        clickStart={x:gx,y:gy}; hoverEnd=null; return;
      }
      const sx=clickStart.x, sy=clickStart.y,
            ex=(hoverEnd||{x:gx}).x,
            ey=(hoverEnd||{y:gy}).y;

      debugEl.textContent='';
      if(!isStraight3(sx,sy,ex,ey)){
        debugEl.textContent='Line must be straight & 3 long.';
      }
      else if(!isConnected(sx,sy,ex,ey)){
        debugEl.textContent='New line must touch at least one point of existing lines.';
      }
      else if(!noNodeReuse(sx,sy,ex,ey)){
        debugEl.textContent='Cannot cross another line’s interior.';
      }
      else if(!noTerritory(sx,sy,ex,ey)){
        debugEl.textContent='Cannot draw in occupied territory.';
      }
      else if(!noMutualTouch(sx,sy,ex,ey)){
        debugEl.textContent='Invalid: line cannot touch end and midpoint simultaneously.';
      }
      else {
        if(mode!=='local'){
          const newLines=[...lines,{sx,sy,ex,ey,playerIndex:turnIndex}];
          const next=(turnIndex+1)%players.length;
          await gameRef.update({lines:newLines,turnIndex:next});
        } else {
          occupy(sx,sy,ex,ey,turnIndex);
          turnIndex=(turnIndex+1)%players.length;
          draw();
          updateInfo();
        }
      }
      clickStart=hoverEnd=null; draw();
    });

  });
  </script>
</body>
</html>