<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Grid Territory Multiplayer</title>
  <style>
    body,html { margin:0; padding:0; height:100%; font-family:sans-serif; }
    #setupOverlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(255,255,255,0.95);
      display:flex; align-items:center; justify-content:center; z-index:10;
    }
    #setupOverlay .dialog {
      background:#fff; padding:20px; border:1px solid #ccc; border-radius:4px;
      max-width:400px; width:100%;
    }
    #hostConfig, #joinConfig { margin-top:12px; }
    #playersConfig .player-row {
      display:flex; align-items:center; margin-bottom:8px;
    }
    #playersConfig input[type="text"] { flex:1; margin-right:8px; }
    #wrapper {
      display:none; height:100%;
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
    }
    #game-container { position:relative; width:420px; height:420px; }
    canvas { position:absolute; top:0; left:0; background:#fff; }
    #info { margin-top:8px; font-weight:600; }
    #debug { margin-top:8px; font-size:.8em; color:#a00; white-space:pre-wrap; }
    button { margin-top:12px; padding:8px 20px; font-size:1rem; cursor:pointer; }
  </style>

  <!-- 1) Firebase UMD (compat) core & Firestore -->
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore-compat.js"></script>
  <!-- 2) YOUR CONFIG: paste from Firebase console → Project settings -->
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCfKDzCpj9KfQ_aglBZ1pHmtkD-XNKs8Gc",
      authDomain: "territory-game-860e8.firebaseapp.com",
      projectId: "territory-game-860e8",
      storageBucket: "territory-game-860e8.firebasestorage.app",
      messagingSenderId: "797594052134",
      appId: "1:797594052134:web:d452b45cdf98b9164de8e7",
      measurementId: "G-28RC8M9MKP"
    };
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
  </script>
</head>
<body>
  <!-- SETUP OVERLAY -->
  <div id="setupOverlay">
    <div class="dialog">
      <h3>Setup Game</h3>
      <label><input type="radio" name="mode" value="local" checked> Local</label>
      <label style="margin-left:10px;"><input type="radio" name="mode" value="host"> Host Online</label>
      <label style="margin-left:10px;"><input type="radio" name="mode" value="join"> Join Online</label>

      <!-- Local or Host -->
      <div id="hostConfig">
        <br/>
        <label>Players:
          <input type="number" id="playerCount" min="2" max="8" value="2"/>
        </label>
        <div id="playersConfig"></div>
      </div>

      <!-- Join -->
      <div id="joinConfig" style="display:none;">
        <br/>
        <input id="joinGameId" type="text" placeholder="Enter Game ID to join" />
      </div>

      <button id="startBtn">Start Game</button>
    </div>
  </div>

  <!-- GAME UI -->
  <div id="wrapper">
    <h2>Grid Territory</h2>
    <div id="game-container">
      <canvas id="gameCanvas" width="420" height="420"></canvas>
    </div>
    <div id="info">Waiting…</div>
    <div id="debug"></div>
    <button id="restartBtn">Restart Game</button>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const $ = id => document.getElementById(id);

      // Setup elements
      const modeRadios    = document.getElementsByName('mode');
      const hostConfig    = $('hostConfig');
      const joinConfig    = $('joinConfig');
      const playerCountIn = $('playerCount');
      const playersConfig = $('playersConfig');
      const joinGameId    = $('joinGameId');
      const startBtn      = $('startBtn');

      let mode = 'local', players = [], gameRef = null;

      // Show/hide config
      function updateConfigDisplay() {
        mode = document.querySelector('input[name=mode]:checked').value;
        hostConfig.style.display = (mode==='local'||mode==='host')?'block':'none';
        joinConfig.style.display = (mode==='join')?'block':'none';
        if (mode==='local'||mode==='host') renderPlayerConfig();
      }
      modeRadios.forEach(r => r.addEventListener('change', updateConfigDisplay));
      updateConfigDisplay();

      // Render name/color inputs
      function renderPlayerConfig() {
        playersConfig.innerHTML = '';
        const count = +playerCountIn.value;
        const defaultColors = ['#e6194b','#3cb44b','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c'];
        for (let i=0; i<count; i++){
          const row = document.createElement('div');
          row.className = 'player-row';
          row.innerHTML = `
            <input id="name${i}" type="text" placeholder="Player ${i+1} name" />
            <input id="color${i}" type="color" value="${defaultColors[i]}" />
          `;
          playersConfig.appendChild(row);
        }
      }
      playerCountIn.addEventListener('change', renderPlayerConfig);

      // Start button
      startBtn.onclick = async () => {
        // Gather players
        if (mode==='local'||mode==='host'){
          const count = +playerCountIn.value;
          players = [];
          for (let i=0; i<count; i++){
            const name  = $(`name${i}`).value.trim() || `Player ${i+1}`;
            const color = $(`color${i}`).value;
            players.push({name, color});
          }
        }

        if (mode==='join'){
          const gid = joinGameId.value.trim();
          if (!gid) return alert('Enter a Game ID');
          $('info').textContent = `Joining ${gid}…`;
          await initOnline(gid, false);
        }
        else if (mode==='host'){
          const gid = Math.random().toString(36).substr(2,9);
          history.replaceState(null,'','?game='+gid);
          $('info').textContent = `Hosting ${gid}…`;
          await initOnline(gid, true);
        }
        else {
          initLocal();
        }

        $('setupOverlay').style.display='none';
        $('wrapper').style.display='flex';
      };

      // --- Game state & drawing ---
      const gridSize=21, cellPx=20;
      const canvas=$('gameCanvas'), ctx=canvas.getContext('2d');
      let turnIndex=0, lines=[], cells=[], nodes, horiz, vert;
      let clickStart=null, hoverEnd=null;

      function px2g(px){return Math.round(px/cellPx)}
      function g2px(g){return g*cellPx}

      function makeEmptyCells(){
        return Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(0));
      }

      function computeStateFromLines(){
        nodes=Array.from({length:gridSize},()=>Array(gridSize).fill(false));
        horiz=Array.from({length:gridSize},()=>Array(gridSize-1).fill(false));
        vert =Array.from({length:gridSize-1},()=>Array(gridSize).fill(false));
        cells=makeEmptyCells();
        for(const ln of lines){
          occupyEdges(ln.sx,ln.sy,ln.ex,ln.ey);
          fillTerritories(ln.playerIndex);
        }
      }

      function occupyEdges(sx,sy,ex,ey){
        if(sx===ex){
          const x=sx,y0=Math.min(sy,ey);
          for(let d=0;d<3;d++){
            vert[y0+d][x]=true;
            nodes[y0+d][x]=nodes[y0+d+1][x]=true;
          }
        } else {
          const y=sy,x0=Math.min(sx,ex);
          for(let d=0;d<3;d++){
            horiz[y][x0+d]=true;
            nodes[y][x0+d]=nodes[y][x0+d+1]=true;
          }
        }
      }

      function fillTerritories(playerIdx){
        const visited=Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(false));
        const queue=[];
        for(let i=0;i<gridSize-1;i++){
          [[0,i],[gridSize-2,i],[i,0],[i,gridSize-2]].forEach(([x,y])=>{
            if(!visited[y][x]){
              visited[y][x]=true; queue.push({x,y});
            }
          });
        }
        const canPass=(x,y,nx,ny)=>
          x===nx ? !horiz[Math.min(y,ny)+1][x]
                 : !vert [Math.min(x,nx)+1][y];

        while(queue.length){
          const {x,y}=queue.shift();
          [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
            const nx=x+dx, ny=y+dy;
            if(nx>=0&&nx<gridSize-1&&ny>=0&&ny<gridSize-1
               && !visited[ny][nx] && canPass(x,y,nx,ny)){
              visited[ny][nx]=true; queue.push({x:nx,y:ny});
            }
          });
        }
        for(let y=0;y<gridSize-1;y++){
          for(let x=0;x<gridSize-1;x++){
            if(!visited[y][x] && cells[y][x]===0){
              cells[y][x]=playerIdx+1;
            }
          }
        }
      }

      function draw(){
        ctx.clearRect(0,0,420,420);
        // grid
        ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
        for(let i=0;i<=gridSize;i++){
          const p=g2px(i);
          ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,420); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(420,p); ctx.stroke();
        }
        // cells
        for(let y=0;y<gridSize-1;y++){
          for(let x=0;x<gridSize-1;x++){
            const o=cells[y][x];
            if(o>0){
              ctx.globalAlpha=0.2;
              ctx.fillStyle=players[o-1].color;
              ctx.fillRect(g2px(x),g2px(y),cellPx,cellPx);
              ctx.globalAlpha=1;
            }
          }
        }
        // lines
        for(const ln of lines){
          ctx.beginPath();
          ctx.lineWidth=4;
          ctx.strokeStyle=players[ln.playerIndex].color;
          ctx.moveTo(g2px(ln.sx),g2px(ln.sy));
          ctx.lineTo(g2px(ln.ex),g2px(ln.ey));
          ctx.stroke();
        }
        // preview
        if(clickStart&&hoverEnd){
          ctx.beginPath();
          ctx.setLineDash([5,5]);
          ctx.lineWidth=2;
          ctx.strokeStyle='gray';
          ctx.moveTo(g2px(clickStart.x),g2px(clickStart.y));
          ctx.lineTo(g2px(hoverEnd.x),g2px(hoverEnd.y));
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }

      function isStraight3(sx,sy,ex,ey){
        const dx=Math.abs(ex-sx), dy=Math.abs(ey-sy);
        return (dx===3&&dy===0)||(dx===0&&dy===3);
      }
      function interior(sx,sy,ex,ey){
        if(sx===ex){
          const y0=Math.min(sy,ey);
          return [{x:sx,y:y0+1},{x:sx,y:y0+2}];
        } else {
          const x0=Math.min(sx,ex);
          return [{x:x0+1,y:sy},{x:x0+2,y:sy}];
        }
      }
      function noCross(sx,sy,ex,ey){
        const ni=interior(sx,sy,ex,ey);
        return !lines.some(ln=>
          interior(ln.sx,ln.sy,ln.ex,ln.ey)
            .some(a=>ni.some(b=>a.x===b.x&&a.y===b.y))
        );
      }
      function touches(sx,sy,ex,ey){
        return lines.length===0||nodes[sy][sx]||nodes[ey][ex];
      }

      // LOCAL
      function initLocal(){
        turnIndex=0; lines=[]; computeStateFromLines();
        $('info').textContent=`Turn: ${players[turnIndex].name}`;
        draw();
      }
      function localSubmitMove(sx,sy,ex,ey){
        lines.push({sx,sy,ex,ey,playerIndex:turnIndex});
        computeStateFromLines();
        turnIndex=(turnIndex+1)%players.length;
        $('info').textContent=`Turn: ${players[turnIndex].name}`;
        draw();
      }

      // ONLINE
      async function initOnline(gameId,isHost){
        const db = firebase.firestore();
        gameRef = db.collection('games').doc(gameId);
        if(isHost){
          await gameRef.set({players,turnIndex:0,lines:[]});
        }
        const snap = await gameRef.get();
        if(!snap.exists) return alert('Game not found.');
        if(!isHost) players = snap.data().players;
        gameRef.onSnapshot(doc=>{
          const d = doc.data();
          lines = d.lines; turnIndex = d.turnIndex;
          computeStateFromLines();
          $('info').textContent = (isHost?'Host':'Joined')+` — Turn: ${players[turnIndex].name}`;
          draw();
        });
      }
      async function onlineSubmitMove(sx,sy,ex,ey){
        const newLines = [...lines,{sx,sy,ex,ey,playerIndex:turnIndex}];
        const next = (turnIndex+1)%players.length;
        await gameRef.update({lines:newLines,turnIndex:next});
      }

      // COMMON HANDLERS
      canvas.addEventListener('mousemove',e=>{
        if(!clickStart)return;
        const r=canvas.getBoundingClientRect();
        hoverEnd={x:px2g(e.clientX-r.left),y:px2g(e.clientY-r.top)};
        draw();
      });
      canvas.addEventListener('click',async e=>{
        if($('setupOverlay').style.display!=='none')return;
        const r=canvas.getBoundingClientRect();
        const gx=px2g(e.clientX-r.left), gy=px2g(e.clientY-r.top);

        if(!clickStart){
          clickStart={x:gx,y:gy}; hoverEnd=null; return;
        }
        const {x:sx,y:sy}=clickStart;
        const {x:ex,y:ey}=hoverEnd||{x:gx,y:gy};

        if(!isStraight3(sx,sy,ex,ey)){
          $('debug').textContent='Line must be straight and exactly 3 cells long.';
        } else {
          computeStateFromLines();
          if(!touches(sx,sy,ex,ey)){
            $('debug').textContent='Must touch existing node.';
          } else if(!noCross(sx,sy,ex,ey)){
            $('debug').textContent='Line crosses another.';
          } else {
            $('debug').textContent='';
            if(mode==='local') localSubmitMove(sx,sy,ex,ey);
            else {
              try { await onlineSubmitMove(sx,sy,ex,ey); }
              catch(err){ $('debug').textContent='Error: '+err.message; }
            }
          }
        }
        clickStart=null; hoverEnd=null; draw();
      });

      $('restartBtn').onclick=async ()=>{
        if(mode==='local') initLocal();
        else await gameRef.update({lines:[],turnIndex:0});
      };
    });
  </script>
</body>
</html>
