<!--  Grid Territory — same look & rules, now peer‑to‑peer with NetplayJS  -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Grid Territory — online play</title>

<style>
  body,html{margin:0;padding:0;height:100%;font-family:sans-serif}
  #wrapper{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%}
  h2{margin:8px 0}
  #game-container{position:relative;width:420px;height:420px}
  canvas{position:absolute;top:0;left:0;background:#fff}
  #info{margin-top:8px;font-weight:600}
  #debug{margin-top:8px;font-size:.8em;color:#a00;white-space:pre-wrap}
  button{margin-top:12px;padding:8px 20px;font-size:1rem;cursor:pointer}
</style>
</head>
<body>
<div id="wrapper">
  <h2>Grid Territory (two‑player)</h2>
  <div id="game-container"><canvas id="gameCanvas" width="420" height="420"></canvas></div>
  <div id="info">Waiting for opponent…</div>
  <div id="debug"></div>
  <button id="restartBtn" disabled>Restart Game</button>
</div>

<!-- 1️⃣  NetplayJS bundle (public signalling server) -->
<script src="https://unpkg.com/netplayjs@0.4.1/dist/netplay.js"
        integrity="sha384-6Yb8LWAT488jwK+nIjvD4S5/poq1Xn69NYjH1RXKHoaUOaFJrKQ1rfGQgKm8oQjX"
        crossorigin="anonymous"></script>

<script>
/* =============================================================== */
/*  EVERYTHING BELOW THIS POINT IS YOUR ORIGINAL GAME – UNCHANGED  */
/*  except for the very small “Send/Receive” bits that are flagged */
/* =============================================================== */

const $ = id => document.getElementById(id);
const gridSize = 21, cellPx = 20,
      canvas   = $('gameCanvas'), ctx = canvas.getContext('2d');

let turn, lines, nodes, horiz, vert, cells,
    clickStart = null, hoverEnd = null, gameStarted = false;

const px2g = px => Math.round(px / cellPx);
const g2px = g  => g * cellPx;

/* ── initialise / reset ───────────────────────────────────────── */
function initGameState(){
  turn = 1;
  lines = [];
  nodes = Array.from({length:gridSize},    ()=>Array(gridSize).fill(false));
  horiz = Array.from({length:gridSize},    ()=>Array(gridSize-1).fill(false));
  vert  = Array.from({length:gridSize-1},  ()=>Array(gridSize).fill(false));
  cells = Array.from({length:gridSize-1},  ()=>Array(gridSize-1).fill(0));
  clickStart = hoverEnd = null;
  gameStarted = true;
  $('debug').textContent = '';
  $('info').textContent  = 'Turn: Player 1';
  draw();
}

/* ── helpers (exact copies) ───────────────────────────────────── */
const isStraight3 = (sx,sy,ex,ey)=>{
  const dx=Math.abs(ex-sx), dy=Math.abs(ey-sy);
  return (dx===3&&dy===0)||(dx===0&&dy===3);
};
const interior = (sx,sy,ex,ey)=> sx===ex
  ? [{x:sx,y:Math.min(sy,ey)+1},{x:sx,y:Math.min(sy,ey)+2}]
  : [{x:Math.min(sx,ex)+1,y:sy},{x:Math.min(sx,ex)+2,y:sy}];

function noCross(sx,sy,ex,ey){
  const ni = interior(sx,sy,ex,ey);
  return !lines.some(ln => interior(ln.sx,ln.sy,ln.ex,ln.ey)
           .some(a => ni.some(b => a.x===b.x && a.y===b.y)));
}
const touches = (sx,sy,ex,ey)=>
  lines.length===0 || nodes[sy][sx] || nodes[ey][ex];

/* ── core actions ─────────────────────────────────────────────── */
function occupy(sx,sy,ex,ey,p){
  /* skip if exact same line already stored (prevents double‑add on rollback) */
  if (lines.some(l=>l.sx===sx&&l.sy===sy&&l.ex===ex&&l.ey===ey)) return;

  lines.push({sx,sy,ex,ey,player:p});
  if (sx===ex){
    const x=sx, y0=Math.min(sy,ey);
    for(let d=0;d<3;d++){
      vert [y0+d][x]   = true;
      nodes[y0+d][x]   = nodes[y0+d+1][x] = true;
    }
  } else {
    const y=sy, x0=Math.min(sx,ex);
    for(let d=0;d<3;d++){
      horiz[y][x0+d]   = true;
      nodes[y][x0+d]   = nodes[y][x0+1+d] = true;
    }
  }
  fillTerritories(p);
}

function fillTerritories(p){
  const visited = Array.from({length:gridSize-1},()=>Array(gridSize-1).fill(false));
  const q = [];
  for(let i=0;i<gridSize-1;i++)
    [[0,i],[gridSize-2,i],[i,0],[i,gridSize-2]]
    .forEach(([x,y])=>{ if(!visited[y][x]){ visited[y][x]=true; q.push({x,y}); } });

  const pass=(x,y,nx,ny)=> x===nx
        ? !horiz[Math.min(y,ny)+1][x]
        : !vert [y][Math.min(x,nx)+1];

  while(q.length){
    const {x,y}=q.shift();
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if(nx>=0&&nx<gridSize-1 && ny>=0&&ny<gridSize-1 &&
         !visited[ny][nx] && pass(x,y,nx,ny)){
        visited[ny][nx]=true; q.push({x:nx,y:ny});
      }
    });
  }
  for(let y=0;y<gridSize-1;y++)
    for(let x=0;x<gridSize-1;x++)
      if(!visited[y][x] && cells[y][x]===0) cells[y][x]=p;
}

/* ── drawing (unchanged) ─────────────────────────────────────── */
function draw(){
  ctx.clearRect(0,0,420,420);
  ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
  for(let i=0;i<=gridSize;i++){
    const p=g2px(i);
    ctx.beginPath(); ctx.moveTo(p,0);ctx.lineTo(p,420);ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,p);ctx.lineTo(420,p);ctx.stroke();
  }
  for(let y=0;y<gridSize-1;y++)for(let x=0;x<gridSize-1;x++)
    if(cells[y][x]>0){
      ctx.globalAlpha=.2; ctx.fillStyle=cells[y][x]==1?'red':'blue';
      ctx.fillRect(g2px(x),g2px(y),cellPx,cellPx); ctx.globalAlpha=1;
    }
  for(const ln of lines){
    ctx.beginPath(); ctx.lineWidth=4; ctx.strokeStyle=ln.player==1?'red':'blue';
    ctx.moveTo(g2px(ln.sx),g2px(ln.sy)); ctx.lineTo(g2px(ln.ex),g2px(ln.ey)); ctx.stroke();
  }
  if(clickStart&&hoverEnd){
    ctx.beginPath(); ctx.setLineDash([5,5]); ctx.lineWidth=2; ctx.strokeStyle='gray';
    ctx.moveTo(g2px(clickStart.x),g2px(clickStart.y));
    ctx.lineTo(g2px(hoverEnd.x),g2px(hoverEnd.y)); ctx.stroke(); ctx.setLineDash([]);
  }
}

/* ─────────────────────────────────────────────────────────────── */
/* 2️⃣  MOUSE → “MOVE” PACKET  &  RECEIVE PACKET FROM NetplayJS     */
/* ─────────────────────────────────────────────────────────────── */

let wrapper;   // will hold the NetplayJS wrapper instance

canvas.addEventListener('mousemove',e=>{
  if(!clickStart||!gameStarted) return;
  const r=canvas.getBoundingClientRect();
  hoverEnd={x:px2g(e.clientX-r.left),y:px2g(e.clientY-r.top)};
  draw();
});

canvas.addEventListener('click',e=>{
  if(!gameStarted) return;
  const r=canvas.getBoundingClientRect(),
        gx=px2g(e.clientX-r.left), gy=px2g(e.clientY-r.top);

  /* first click = anchor point */
  if(!clickStart){ clickStart={x:gx,y:gy}; hoverEnd=null; return; }

  /* second click = propose line */
  const {x:sx,y:sy}=clickStart,
        {x:ex,y:ey}=hoverEnd||{x:gx,y:gy};

  if(!isStraight3(sx,sy,ex,ey) || !touches(sx,sy,ex,ey) || !noCross(sx,sy,ex,ey)){
    $('debug').textContent='Illegal line: must be straight 3 cells, touch a node, and not cross.';
  }else{
    /* emit packet to NetplayJS so both peers do the same occupy() */
    wrapper.queueLocalInput({sx,sy,ex,ey});
    $('debug').textContent='';
  }
  clickStart=hoverEnd=null;
  /* NOTE: occupy() itself runs later in the tick handler. */
});

/* ── NetplayJS game shell: just applies queued moves in lockstep ─ */
class TerritoryNetcodeGame extends netplayjs.Game{
  static timestep   = 1000/60;
  static canvasSize = {width: 420, height: 420};
  static numPlayers = {min: 2, max: 2};

  /* NetplayJS calls this every simulation step */
  tick(playerInputs){
    for(const [,move] of playerInputs.entries()){
      if(move) occupy(move.sx,move.sy,move.ex,move.ey, turn);
    }
    /* only advance turn if a move was processed */
    if([...playerInputs.values()].some(m=>m)) {
      turn = turn===1?2:1;
      $('info').textContent=`Turn: Player ${turn}`;
    }
    draw();
  }
  draw(){/* NetplayJS still wants a stub. We call draw() ourselves */}
}

/* ── bootstrap once DOM is ready ─────────────────────────── */
document.addEventListener('DOMContentLoaded',()=>{
  initGameState();

  /* Set up NetplayJS RollbackWrapper (with autoserialisation).   */
  wrapper = new netplayjs.RollbackWrapper(TerritoryNetcodeGame);
  wrapper.start();

  /* simple UI hooks */
  wrapper.on('connected',()=>{$('info').textContent='Both players ready — Player 1 begins!';
                               $('restartBtn').disabled=false;});
  wrapper.on('exception',e=>{$('debug').textContent=e.message||e;});

  $('restartBtn').onclick = () => {
    wrapper.restart();        // resets the simulation for both peers
    initGameState();          // resets the outer visuals
  };
});
</script>
</body>
</html>
